# Projektorientierte Programmierung mit C#

## Abgrenzung prozedurale Programmierung
- Unter anderem: Variablen für Speicherung von Daten.
- Kontrollstrukturen für die Erstellung eines Programmablaufs: if, while, for...
- Bibliotheken, Unterprogramme, Prozeduren fassen Variablen und Kontrollstrukturen zusammen.

## Objektorientierte Programmierung
Variablen und Prozeduren (hier genannt Methoden) werden in Klassen zusammengefasst.
    - Variablen, Eigenschaften bilden die Datensätze ab
    - Methoden sind die Klassenspezifischen Funktionen/Prozeduren

## Default entrypoint for a (terminal) C# Program:
```C#
namespace tag01_erstes_projekt
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Running from Main()");
            while (true)
            {
                Console.Write(">");
                String input = Console.ReadLine();
                bool isNumber = Int32.TryParse(input, out int value);
                if (isNumber){
                    Console.WriteLine("Quadriertes Ergebniss: " + value*value + " !");
                }
            }
        }
    }
}
```
## Naming Conventions
|||
|---|---|
|Class| StudenClass|
|Method|GetMarks|
|Local variable|firstName|
|Private variable|avgMarks|
|Constants|Percentile|

## Basics
### Comments
```C#
// Single-line comment

/* Multi-line 
   comment */

// TODO: Adds comment to a task list in Visual Studio

/// Single-line comment used for documentation

/** Multi-line comment 
    used for documentation **/
```
### Formatierte Ausgabe (von Zahlen)
```C#
Console.WriteLine(zahl.ToString("00000"));      // 00123
Console.WriteLine(zahl.ToString("#.##"));       // 12.34
Console.WriteLine(zahl.ToString("#0.##E+0"));   // 12.35 E+2
Console.WriteLine(zahl.ToString("#.##%"));      // 2.5%  <- 0.025 
// Escapebezeichnung (um z.B. # anzuzeigen):
Console.WriteLine(zahl.ToString("\\#00.#E+0\\#")) // #12.35 E+2#
```


### Datentypen
|Datentyp|Speicherplatz in Byte|Wertebrereich|
|---|---|---|
|bool|1|TRUE, FALSE|
|byte|1|0-255|
|int|2|32Bit|
|long|4|64Bit|
|ushort|2|8Bit-0-65535|
|uint|4|32Bit|
|ulong|8|64Bit|
|decimal|16|Dezimalzahl ca. -7.9228E+28 ca. 7.928E+28|
|float|4|Gleitkommazahl ca.-3.4E+28 ca.3.4E+38|
|double|8|Gleitkommazahl ca. -1.99E+308 ca.1.79E+308|
|char|2-4|utf16|
|string|...|Zeichenkette|
- get size, get type
- `sizeof()` returns size of the data type
- `typeof()` returns type of object (ex. string, integer, bool ...)



### Strings
```C#
Length      // returns length of string
Compare()   // compares two strings
Contains()  // true if contains a substring
Equals()    // checks if two strings have same character data
Format()    // Formats a string via the {0} notation by using other primitives.
Trim()      //remove whitespace from end & start
```
- Other notable Operations:
    - Clone, CompareTo, EndsWith, GetHashCode, GetTypeCode, IndexOf, ToLower, ToUpper, Insert, IsNormalized, LastIndexOf, Remove, Replace, Split, StartsWith, Substring, ToCharArray
### Type conversions
-implicit type conversions: Werden automatisch wo Typsicher von C# vorgenommen (von i32->i63 usw)
- explicit type conversions: Müssen explizit geschrieben werden, da hier nicht garantiert werden kann, dass daten verloren gehen.
- Type conversion, Type checking
    - `AsInt()` String into integer. 
    - `IsInt()` Check if input is a String.
    - `AsDateTime()`
    - `IsDatetime()`
    - `ToString()`
- ToConversions:
    - `ToChar()`, `ToByte()`, `ToDecimal()` ...
- example of where it could go wrong
```C#
// nach Eingabe eines Radius soll das Programm das Volumen ausgeben
        public static void Beispiel1()
        {
            double radius = 0, volumen = 0;

            Console.Write("Radius eingeben: ");
            String input = Console.ReadLine();
            bool isNumber = double.TryParse(input, out radius);
            while (!isNumber)
            {
                Console.Write("ERROR ungültige Eingabe, Radius erneut eingeben:");
                input = Console.ReadLine();
                isNumber = double.TryParse(input, out radius);
            }

            // volumen =  4 / 3 * Math.PI* Math.Pow(radius,2);  // WILL USE I32 for 4/3 -> 4/3=1
            // volumen = Math.PI *4/3 would also work since the compiler will go from left to right, inferring the type.
            volumen =  4.0 / 3.0 * Math.PI* Math.Pow(radius,2);

            Console.WriteLine("Volumen: " + volumen.ToString("#.###"));
        }
```
## Objects
### Modifiers
|name|description+
|---|---|
|public|accessible by any other code|
|private|only accessible from within the same class or struct|
|protected|only accessible from within the same class or struct or derived class|
|internal|accessible by any code in the same assembly, but not from another assembly|
|protected internal|accessible by any code in the same assembly, or by any derived class in another assembly|
|abstract|class can only be used as base of other classes|
|async|asynchronous method|
|const|the field can not be modified|
|event|declares an event|
|extern|indicates that the method is implemented externally|
|new|explicitly hides a member inherited from a base class|
|override|provides a new implementation of a virtual member inherited from a base class|
|partial|define a partial class, strut or method|
|read-only|field can only be assigned in declaration or in constructor (when creating an instance)|
|sealed|This class can not be inherited|
|static|no instances/objects for this class need to be crated. It already exists by itself (singleton ish etc.)|
|unsafe|declares unsafe context|
|virtual|Declares a method or an accessor whose implementation can be changed by an overriding member in a derived class|
|volatile|Indicates that a field can be modified in the program by something such as the operating system, the hardware, or a concurrently executing thread|

```C#
namespace tag01_erstes_projekt
{
    internal class Programm{
        static void Main(){
            Artikel a1 = new Artikel();
            a1.Bezeichung = "Hose";
            a1.Preis = 23.45;
            a1.Menge = 10;

            Artikel a2 = new Artikel { Bezeichung="Jacke", Preis = 19.99, Menge = 3};
        }
    }
    internal class Artikel
    {
        public string Bezeichung;
        public double Preis;
        public int Menge;
    }
}

```


## Exception Handling
```C#
try{} catch (Exception e){throw;}
```

## Handling Files
||||
|---|---|---|
|File.Exists(path)|Check  the existence of the file in the path|
|File.ReadAllLines(path)|Read all the lines from the file in the path|
|File.ReadAllText(path)|Read all the text from the file and return a string|
|File.Copy(path1, destPath))|Copy content from one file to antoher|
|File.Delte|Delete an existing file from the path|


## Reference Type
- point to memory location (heap) instead of direct value (stack).
- examples: object, dynamic, string.
```C#
// when a value type is converted to object type this is called boxing (vs unboxing):
object obj;
obj = 100;  // this is boxing

// you can stoire any type of value in the dynamic data type variable:
// type checking for those happens at runtime:
dynamic variable_name = 20;
```
### Pointer Type
```C#
char* some_pointer;
int* another_pointer;
```

## Functional methods
```c#
// map() is Select
Enumerable.Range(1, 10).Select(x => x + 2);

// reduce() is Aggregate
Enumerable.Range(1, 10).Aggregate(0, (acc, x) => acc + x);

// filter() is Where
Enumerable.Range(1, 10).Where(x => x % 2 == 0);
```