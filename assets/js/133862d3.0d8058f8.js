"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[784],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),u=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(i.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=o,h=p["".concat(i,".").concat(d)]||p[d]||m[d]||a;return n?r.createElement(h,l(l({ref:t},c),{},{components:n})):r.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:o,l[1]=s;for(var u=2;u<a;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9913:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var r=n(7462),o=(n(7294),n(3905));const a={},l="Closures and Iterators in Rust",s={unversionedId:"rust/09functional",id:"rust/09functional",title:"Closures and Iterators in Rust",description:"Closures",source:"@site/docs/rust/09functional.md",sourceDirName:"rust",slug:"/rust/09functional",permalink:"/md/rust/09functional",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/09functional.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Testing in Rust",permalink:"/md/rust/08testing"},next:{title:"Smart Pointers in Rust",permalink:"/md/rust/10smartpointers"}},i={},u=[{value:"Closures",id:"closures",level:2},{value:"Ownership for closures",id:"ownership-for-closures",level:3},{value:"Closure traits",id:"closure-traits",level:3},{value:"Iterator",id:"iterator",level:2},{value:"How Iterators accomplish that:",id:"how-iterators-accomplish-that",level:3},{value:"Different Methods that consume the Iterator",id:"different-methods-that-consume-the-iterator",level:4},{value:"Methods that produce other Iterators",id:"methods-that-produce-other-iterators",level:4},{value:"iterator to make code simpler",id:"iterator-to-make-code-simpler",level:3},{value:"Iterator with Result",id:"iterator-with-result",level:3},{value:"Comparing Performance: Loops vs. Iterators",id:"comparing-performance-loops-vs-iterators",level:3}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"closures-and-iterators-in-rust"},"Closures and Iterators in Rust"),(0,o.kt)("h2",{id:"closures"},"Closures"),(0,o.kt)("p",null,"Anonymous functions that capture their environment. That we save in a variable or pass as arguments to other functions."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"because of the narrow scope of closures (vs functions/methods) we can often omit explicit type annotations.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let some_closure = |num| {\n    num + 2\n};\nlet some_closure_with_types = |num: u32| -> u32 {\n    println!("doint something");\n    num + 1\n};\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"as usual it is also possible to shorten closures syntax a bit:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n")),(0,o.kt)("p",null,"As a note: in Rust a closure without explicit types can not infer different two or more types at the same time."),(0,o.kt)("h3",{id:"ownership-for-closures"},"Ownership for closures"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let mut list = vec![1, 2, 3];\nprintln!("At the start: {:?}", list);\n\nlet only_borrows = || println!("From closure: {:?}", list);\nonly_borrows();\n\nlet mut borrows_mutably = || list.push(4);\n//println!("cant acess list since it belongs currently to borrows_mut() {:?}",list);\nborrows_mutably();\n// after here list is "free" again.\n\nprintln!("At the end: {:?}", list);\n')),(0,o.kt)("p",null,"In the following example we move the whole list into the closure. This needs to happen since we dont know when the multithreaded closure (in its own thread) will finish. It could finish before the main function, or main could finish first."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use std::thread;\nfn main() {\n    let list = vec![1,2,3];\n    thread::spawn(move || println!("This gets executed in its own thread and list moved to this thread {:?}",list))\n        .join().unwrap();\n}\n')),(0,o.kt)("h3",{id:"closure-traits"},"Closure traits"),(0,o.kt)("p",null,"Closures automatically implement, one, two or trhee of these ",(0,o.kt)("inlineCode",{parentName:"p"},"Fn")," traits:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"FnOnce")," applies to closures that can be called only once. Closures that moves captured values out of its body will only implement only this, because they can only be called once."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"FnMut")," applies to closures, that can modify captured values out of their body, but do not move values out their body themselfs. Can be called multiple times."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Fn")," applies to closures that do not move values out of their body, or modify values. Can be called multiple times. (these are save for concurrency)")),(0,o.kt)("p",null,"The following example calls ",(0,o.kt)("inlineCode",{parentName:"p"},"the sort_by_key()")," function. That one is implemented with ",(0,o.kt)("inlineCode",{parentName:"p"},"FnMut"),". This way it will allow flexible closures as input. But Fails once we were to try to move someting out of its scope etc."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut count_operations = 0;\n    list.sort_by_key( |r| {\n        count_operations += 1;\n        r.width\n    });\n    println!("{:#?}, sorted in {count_operations} operations.", list);\n}\n')),(0,o.kt)("h2",{id:"iterator"},"Iterator"),(0,o.kt)("p",null,"In rust iterators are ",(0,o.kt)("em",{parentName:"p"},"lazy"),", meaning we need to consume the iterator to use it up. An iterator by itself does nothing."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"iterators can not just loop over indexable structures like a vector but also map etc...")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![1,2,3,4,5];\n\n// create the iterator\nlet v_iter = v.iter();\n\n// consume the iterator (if we just looped over v we would consume v)\nfor val in v_iter {\n    println!("value: {}", val);\n}\n\nprintln!("{:?}", v);    // now v is still there, while v_iter is consumed\n')),(0,o.kt)("h3",{id:"how-iterators-accomplish-that"},"How Iterators accomplish that:"),(0,o.kt)("p",null,"All iterators implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterator")," trait. This type requires implementors to define the ",(0,o.kt)("inlineCode",{parentName:"p"},"next()")," method, that returns one item at a time, wrapped in either ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"None")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We could even call the next method directly:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let v = vec![1,2,3];\n\n\n// the iterator needs to be mutable since we change the iterator by calling next():\nlet mut v_iter = v.iter();              \n\nassert_eq!(v_iter.next(), Some(&1));    // we use up the first element of the iterator\nassert_eq!(v_iter.next(), Some(&2));    // we use up the 2nd\nassert_eq!(v_iter.next(), Some(&3));    // we use up the last\nassert_eq!(v_iter.next(), None);        // no elements are left in the iterator\n")),(0,o.kt)("h4",{id:"different-methods-that-consume-the-iterator"},"Different Methods that consume the Iterator"),(0,o.kt)("p",null,"Our for in loop, the next call or ",(0,o.kt)("inlineCode",{parentName:"p"},"v_iter.sum()")," are just a few of premade methods to consume iterators. These kinds of methods are called ",(0,o.kt)("inlineCode",{parentName:"p"},"consuming adaptors")),(0,o.kt)("h4",{id:"methods-that-produce-other-iterators"},"Methods that produce other Iterators"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Iterator adaptors")," are methods that dont consume the iterator, but instead produce different iterators by chaning some aspects."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The most common example could be the ",(0,o.kt)("inlineCode",{parentName:"li"},"map")," method.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![1,2,3,4,5];\n// create & consume the new iterator with each value doubled\nlet v2: Vec<i32> = v.iter().map(|x|x*2).collect();\nprintln!("{:?}", v2);\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"another example implementing a ",(0,o.kt)("inlineCode",{parentName:"li"},"filter"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let v = vec![1,2,3,4,5,6,7,8,9];\n    let  v2 = custom_filter(v);\n    println!("{:?}",v2)\n}\n\nfn custom_filter(v: Vec<i32>) -> Vec<i32>{\n    v.into_iter().filter(|x| *x>5).collect()\n}\n')),(0,o.kt)("h3",{id:"iterator-to-make-code-simpler"},"iterator to make code simpler"),(0,o.kt)("p",null,"example of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/vincepr/rsgrep"},"https://github.com/vincepr/rsgrep")," to show the same function once with a for loop and once written with an iterator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// searches a string for a substring. Returns array of lines that include substing.\npub fn search_str<'a>(substr: &str, data: &'a str) -> Vec<&'a str> {\n    let mut found_lines:Vec<&str> = vec![];\n    for line in data.lines() {\n        if line.contains(substr) {\n            found_lines.push(line);\n        }\n    }\n    found_lines\n}\n\n// rewritten above with an iterator (more readable)\npub fn search_str<'a>(substr: &str, data: &'a str) -> Vec<&'a str> {\n    data\n        .lines()\n        .filter(|line| line.contains(substr))\n        .collect()\n}\n")),(0,o.kt)("h3",{id:"iterator-with-result"},"Iterator with Result"),(0,o.kt)("p",null,"Sometimes we must collect iterators that Return Results (or Options). We usually want to propagate the Error up, or wrap each element in the Ok or Err."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let results = [Ok(1), Err("nope"), Ok(3), Err("bad")];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the first error\nassert_eq!(Err("nope"), result);\n\nlet results = [Ok(1), Ok(3)];\n\nlet result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n\n// gives us the list of answers\nassert_eq!(Ok(vec![1, 3]), result);\n')),(0,o.kt)("h3",{id:"comparing-performance-loops-vs-iterators"},"Comparing Performance: Loops vs. Iterators"),(0,o.kt)("p",null,"Iterators, though high level abstraction, get compiled down to roughly the same machine code in rust. (Zero-cost-abstraction principle in rust)"))}p.isMDXComponent=!0}}]);