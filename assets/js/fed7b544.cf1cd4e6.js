"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[5992],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="Smart Pointers in Rust",l={unversionedId:"rust/10smartpointers",id:"rust/10smartpointers",title:"Smart Pointers in Rust",description:"The most common kind of pointer in Rust is a reference. ( indicated by the & Symbol) They do not have any special capabilities or overhead attached to them.",source:"@site/docs/rust/10smartpointers.md",sourceDirName:"rust",slug:"/rust/10smartpointers",permalink:"/md/rust/10smartpointers",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/10smartpointers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Closures and Iterators in Rust",permalink:"/md/rust/09functional"},next:{title:"OOP in Rust - Object-Oriented paradigms in Rust",permalink:"/md/rust/11OOP"}},s={},p=[{value:"Box to point to Data on the Heap",id:"box-to-point-to-data-on-the-heap",level:2},{value:"Linked List - Example to 1. : Enabling recursive Types with Boxes",id:"linked-list---example-to-1--enabling-recursive-types-with-boxes",level:3},{value:"Deref Trait",id:"deref-trait",level:2},{value:"Implicit Deref Coercion",id:"implicit-deref-coercion",level:3},{value:"Drop Trait",id:"drop-trait",level:2},{value:"Running Code on Cleanup with the Drop Trait",id:"running-code-on-cleanup-with-the-drop-trait",level:3},{value:"Dropping a Value Early",id:"dropping-a-value-early",level:3},{value:"<code>Rc&lt;T&gt;</code> Reference counting Smart Pointer",id:"rct-reference-counting-smart-pointer",level:2},{value:"<code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern",id:"refcellt-and-the-interior-mutability-pattern",level:2},{value:"use case: Mock Objects",id:"use-case-mock-objects",level:3},{value:"Cow - Clone-On-Write type",id:"cow---clone-on-write-type",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"smart-pointers-in-rust"},"Smart Pointers in Rust"),(0,r.kt)("p",null,"The most common kind of pointer in Rust is a reference. ( indicated by the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," Symbol) They do not have any special capabilities or overhead attached to them."),(0,r.kt)("p",null,"Rust implements different kinds of smart points in the std-lib. One example would be a ",(0,r.kt)("em",{parentName:"p"},"reference counting")," pointer type, that can have multiple owners, by keeping track of the numbers of owners and cleaning up when no one remains."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Often smart pointers own the data they point to in rust. While refernces do not (only borrow it)"),(0,r.kt)("li",{parentName:"ul"},"Smart pointers are usually structs and implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deref")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Drop")," traits.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deref")," trait allows an instance of the smartpointer to behave like a reference in our code."),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Drop")," trait allows custom behavior when going out of scope."))),(0,r.kt)("li",{parentName:"ul"},"Some examples of smart pointers:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Vec<T>")," struct."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Box<T>")," for allocating values on the heap."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Rc<T>")," a reference counting type to enable multiple/shared ownership."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Ref<T>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"RefMut<T>")," accessed trough ",(0,r.kt)("inlineCode",{parentName:"li"},"RefCell<T>")," a type that enforces the borrowing rules at runtime instead of compile time.")))),(0,r.kt)("h2",{id:"box-to-point-to-data-on-the-heap"},"Box to point to Data on the Heap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let x = Box::new(7),\nprintln!("x:{}",x);\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," allow us to store data on the heap rather than the stack. Only the box pointer remains on the heap. Boxes have no performance overhead other than storing the data on the heap itself. Some common usecases:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"when we have a type of unknown (at compiletime) size. But we want to use that value in a context that requires an exact size."),(0,r.kt)("li",{parentName:"ol"},"Large amount of data we want to transfer ownership of, but ensure the data does not get copied. (no loss of performance other than a reference created)"),(0,r.kt)("li",{parentName:"ol"},"When you want to own a value and you only care that it implements a particular trait.")),(0,r.kt)("h3",{id:"linked-list---example-to-1--enabling-recursive-types-with-boxes"},"Linked List - Example to 1. : Enabling recursive Types with Boxes"),(0,r.kt)("p",null,"Rust needs to know at compile time how much space to allocate for a recursive type. But the nesting of values of recursive types stacks it cant be implemented like that. Boxes solve this by always beeing the same size (1 pointer big)."),(0,r.kt)("p",null,"A cons list is a data structure from the Lisp language and is made up of nested pairs. It is the Lisp version of a linked list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// this will not compile since: recursive type `List` has infinite size\nenum List {\n    Node(i32, List),\n    Nil,\n}\nfn main() {\n    use crate::List::{Node, Nil};\n    let list = Node(1, Node(2, Node(3, Nil)));\n}\n")),(0,r.kt)("p",null,"The solution is to implement it with a Box instead (as the compiler suggests):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// here is the working LinkedList of generic Type:\n#[derive(Debug)]\nenum List<T> {\n    Node(T, Box<List<T>>),\n    Nil,\n}\nfn main() {\n    use crate::List::{Node, Nil};\n    let list = Node(1, Box::new(Node(2, Box::new(Node(3, Box::new(Nil))))));\n    println!("{:?}", list);\n}\n')),(0,r.kt)("h2",{id:"deref-trait"},"Deref Trait"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"quick example of pointer behavior and dereferencing:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let x = 99;\nlet y = &x;\nassert_eq!(99,x);\nassert_eq!(99, *y);     // dereference operator: we follor the reference to the value.\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"building our own ",(0,r.kt)("inlineCode",{parentName:"li"},"Box<T>")," -like type. (it wont actually store data on the heap, were just focusing on the Deref Trait and functionality)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// this wont compile, because it is missing the Deref implementation\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n\n}\n\nstruct MyBox<T>(T);\nimpl <T> MyBox<T> {\n    fn new(r: T) -> MyBox<T>{\n        MyBox(r)\n    }\n}\n")),(0,r.kt)("p",null,"The above will not compile, since it is missing a implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait. So we implement it like below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// so we add our deref implementation\nuse std::ops::Deref;\nimpl<T> Deref for MyBox<T> {\n    type Target = T;                // associated type for the Deref Trait to use.\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n")),(0,r.kt)("h3",{id:"implicit-deref-coercion"},"Implicit Deref Coercion"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Deref coercion")," is a convenience feature that converts one Reference to another (ex ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"). Because String implements the Deref trait such, that it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.kt)("p",null,"Deref coercion was added to Rust so that programmers writing function and method calls don\u2019t need to add as many explicit references and dereferences with ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"*")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn test(name: &str) {\n    println!("{name}");\n}\nfn main() {\n    let m = MyBox::new(String::from("Rust"));\n\n    // instead of having to write the full casting like this:\n    test(&(*m)[..]);\n\n    // deref coercion allows us to just write:\n    test(&m)\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"(*m)")," dereferences the ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBox<String>")," into a String. Then the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[..]")," take a string slice of the String that is equal to the whole string to match the signature of hello. This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically."),(0,r.kt)("p",null,"When the Deref trait is involved, Rust will use the deref function as many times as necessary to get a reference to match the parameters type."),(0,r.kt)("h2",{id:"drop-trait"},"Drop Trait"),(0,r.kt)("h3",{id:"running-code-on-cleanup-with-the-drop-trait"},"Running Code on Cleanup with the Drop Trait"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," lets us customize what happens when a value is about to go out of scope. For example when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," goes out of scope it will deallocate the space on the heap, the box points to."),(0,r.kt)("p",null,"This way no memory will leak. The following example will print out whenever an instance of our CustomPointer goes out of scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'struct CustomSmartPointer {\n    data: String,\n}\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!("Dropping CustomSmartPointer with data `{}`!", self.data);\n        // this is where one could implement cleanup functionality\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from("first pointer"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from("second blah blah"),\n    };\n    println!("CustomSmartPointers created.");\n}\n')),(0,r.kt)("h3",{id:"dropping-a-value-early"},"Dropping a Value Early"),(0,r.kt)("p",null,"Rust does not allow us to call the drop function manually. This could be neccessary when implementing Smartpointers for a lock and unlock functionality for multithreading. "),(0,r.kt)("p",null,"Instead we have to use ",(0,r.kt)("inlineCode",{parentName:"p"},"std::mem::drop")," to release the lock so that other code in the same scope can aquire the lock."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let c = CustomSmartPointer {\n        data: String::from("some data"),\n    };\n    println!("CustomSmartPointer created.");\n    //c.drop();     // this is not allowed \n    drop(c);\n    println!("CustomSmartPointer dropped before the end of main.");\n}\n')),(0,r.kt)("h2",{id:"rct-reference-counting-smart-pointer"},(0,r.kt)("inlineCode",{parentName:"h2"},"Rc<T>")," Reference counting Smart Pointer"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"is only for use in single threaded scendarios. Example: we have a graph data structure, multiple nodes might point to the same next node. That node is conceptually owned by those nodes and should be cleaned up when it has no owners left."),(0,r.kt)("p",null,"Those immutable References allow sharing data between multiple parts of the program for reading only."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::rc::Rc;\nenum SharedList<T>{\n    Node(T, Rc<SharedList<T>>),\n    Nil,\n}\n\nfn main(){\n    use crate::SharedList::{Node, Nil};\n\n    let a = Rc::new(Node(5, Rc::new(Node(10, Rc::new(Nil)))));\n    println!("count after creating a: {}", Rc::strong_count(&a));           //-> 1\n\n    let b = Node(2, Rc::clone(&a));\n    println!("count after creating b: {}", Rc::strong_count(&a));           //-> 2\n    {\n        let c = Node(8, Rc::clone(&a));\n        println!("count after creating c: {}", Rc::strong_count(&a));       //-> 3\n    }\n    println!("count after c goes out of scope: {}", Rc::strong_count(&a));  //-> 2\n}\n')),(0,r.kt)("p",null,"We could have used ",(0,r.kt)("inlineCode",{parentName:"p"},"a.clone()")," aswell, but ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::clone()")," is the convention in rust. This iway it is easy to distinguish between deep copy kinds of clones and the clones that increase our reference count. When looking for perfomance problems in code, all wee need is to consider is the deep copy clones and we can disregard the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc::clone")," ones."),(0,r.kt)("h2",{id:"refcellt-and-the-interior-mutability-pattern"},(0,r.kt)("inlineCode",{parentName:"h2"},"RefCell<T>")," and the Interior Mutability Pattern"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Interior Mutability")," is a design pattern in Rust, that allows to mutate data, even when there already an immutable refference to that data. This is accomplished with the ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," package and by manually guaranteeing memory safety."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," type wraps the unsafe calls in a save to use API."),(0,r.kt)("p",null,"With normal references the borrowing rules are enforced at compile time. With ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," these invariants are enforced at runtime. So if refernces break, it wont compile. If ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," break these rules, the programm will panic."),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"RefCell is only for use in a single-threaded context."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RefCell<T>")," allows mutable borrows checked at runtime. You can mutate the value inside the ",(0,r.kt)("inlineCode",{parentName:"li"},"RefCell<T>")," even when it itself is immutable.")),(0,r.kt)("h3",{id:"use-case-mock-objects"},"use case: Mock Objects"),(0,r.kt)("p",null,"Sometimes during tesing a programmer will have to use a ",(0,r.kt)("em",{parentName:"p"},"test double"),". This type only exists in place of another type, in order to observe particular behavior and assert it is implemented correctly."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Mock Objects")," are specific types of test doubles that record what happens during a test."),(0,r.kt)("p",null,"Here\u2019s the scenario we\u2019ll test: we\u2019ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user\u2019s quota for the number of API calls they\u2019re allowed to make, for example."),(0,r.kt)("p",null,"Consumers of the Library would have to implement the Messenger Trait and therefor the send method. (For example sending a Notification Mail etc.)"),(0,r.kt)("p",null,"For testing purpose we want a mock object that, instead of sending an mail just keeps track of the messages it is told to send. So we can assert it is the messages we expect."),(0,r.kt)("h2",{id:"cow---clone-on-write-type"},"Cow - Clone-On-Write type"),(0,r.kt)("p",null,"Cow is a clone-on-write smart pointer."),(0,r.kt)("p",null,"It can enclose and provide immutable access to borrowed data. (and clone the data lazily when mutation or ownership is required)"))}u.isMDXComponent=!0}}]);