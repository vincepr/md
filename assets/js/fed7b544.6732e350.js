"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[5992],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="Smart Pointers in Rust",l={unversionedId:"rust/10smartpointers",id:"rust/10smartpointers",title:"Smart Pointers in Rust",description:"The most common kind of pointer in Rust is a reference. ( indicated by the & Symbol) They do not have any special capabilities or overhead attached to them.",source:"@site/docs/rust/10smartpointers.md",sourceDirName:"rust",slug:"/rust/10smartpointers",permalink:"/md/rust/10smartpointers",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/10smartpointers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Closures and Iterators in Rust",permalink:"/md/rust/09functional"},next:{title:"Basic Examples",permalink:"/md/rust/examples/01basic"}},s={},p=[{value:"Box to point to Data on the Heap",id:"box-to-point-to-data-on-the-heap",level:2},{value:"Linked List - Example to 1. : Enabling recursive Types with Boxes",id:"linked-list---example-to-1--enabling-recursive-types-with-boxes",level:3},{value:"Deref Trait",id:"deref-trait",level:2},{value:"Implicit Deref Coercion",id:"implicit-deref-coercion",level:3},{value:"Drop Trait",id:"drop-trait",level:2},{value:"Running Code on Cleanup with the Drop Trait",id:"running-code-on-cleanup-with-the-drop-trait",level:3},{value:"Dropping a Value Early",id:"dropping-a-value-early",level:3}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"smart-pointers-in-rust"},"Smart Pointers in Rust"),(0,r.kt)("p",null,"The most common kind of pointer in Rust is a reference. ( indicated by the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," Symbol) They do not have any special capabilities or overhead attached to them."),(0,r.kt)("p",null,"Rust implements different kinds of smart points in the std-lib. One example would be a ",(0,r.kt)("em",{parentName:"p"},"reference counting")," pointer type, that can have multiple owners, by keeping track of the numbers of owners and cleaning up when no one remains."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Often smart pointers own the data they point to in rust. While refernces do not (only borrow it)"),(0,r.kt)("li",{parentName:"ul"},"Smart pointers are usually structs and implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deref")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Drop")," traits.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deref")," trait allows an instance of the smartpointer to behave like a reference in our code."),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Drop")," trait allows custom behavior when going out of scope."))),(0,r.kt)("li",{parentName:"ul"},"Some examples of smart pointers:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Vec<T>")," struct."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Box<T>")," for allocating values on the heap."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Rc<T>")," a reference counting type to enable multiple/shared ownership."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Ref<T>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"RefMut<T>")," accessed trough ",(0,r.kt)("inlineCode",{parentName:"li"},"RefCell<T>")," a type that enforces the borrowing rules at runtime instead of compile time.")))),(0,r.kt)("h2",{id:"box-to-point-to-data-on-the-heap"},"Box to point to Data on the Heap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let x = Box::new(7),\nprintln!("x:{}",x);\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," allow us to store data on the heap rather than the stack. Only the box pointer remains on the heap. Boxes have no performance overhead other than storing the data on the heap itself. Some common usecases:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"when we have a type of unknown (at compiletime) size. But we want to use that value in a context that requires an exact size."),(0,r.kt)("li",{parentName:"ol"},"Large amount of data we want to transfer ownership of, but ensure the data does not get copied. (no loss of performance other than a reference created)"),(0,r.kt)("li",{parentName:"ol"},"When you want to own a value and you only care that it implements a particular trait.")),(0,r.kt)("h3",{id:"linked-list---example-to-1--enabling-recursive-types-with-boxes"},"Linked List - Example to 1. : Enabling recursive Types with Boxes"),(0,r.kt)("p",null,"Rust needs to know at compile time how much space to allocate for a recursive type. But the nesting of values of recursive types stacks it cant be implemented like that. Boxes solve this by always beeing the same size (1 pointer big)."),(0,r.kt)("p",null,"A cons list is a data structure from the Lisp language and is made up of nested pairs. It is the Lisp version of a linked list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// this will not compile since: recursive type `List` has infinite size\nenum List {\n    Node(i32, List),\n    Nil,\n}\nfn main() {\n    use crate::List::{Node, Nil};\n    let list = Node(1, Node(2, Node(3, Nil)));\n}\n")),(0,r.kt)("p",null,"The solution is to implement it with a Box instead (as the compiler suggests):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// here is the working LinkedList of generic Type:\n#[derive(Debug)]\nenum List<T> {\n    Node(T, Box<List<T>>),\n    Nil,\n}\nfn main() {\n    use crate::List::{Node, Nil};\n    let list = Node(1, Box::new(Node(2, Box::new(Node(3, Box::new(Nil))))));\n    println!("{:?}", list);\n}\n')),(0,r.kt)("h2",{id:"deref-trait"},"Deref Trait"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"quick example of pointer behavior and dereferencing:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let x = 99;\nlet y = &x;\nassert_eq!(99,x);\nassert_eq!(99, *y);     // dereference operator: we follor the reference to the value.\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"building our own ",(0,r.kt)("inlineCode",{parentName:"li"},"Box<T>")," -like type. (it wont actually store data on the heap, were just focusing on the Deref Trait and functionality)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// this wont compile, because it is missing the Deref implementation\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n\n}\n\nstruct MyBox<T>(T);\nimpl <T> MyBox<T> {\n    fn new(r: T) -> MyBox<T>{\n        MyBox(r)\n    }\n}\n")),(0,r.kt)("p",null,"The above will not compile, since it is missing a implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," trait. So we implement it like below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// so we add our deref implementation\nuse std::ops::Deref;\nimpl<T> Deref for MyBox<T> {\n    type Target = T;                // associated type for the Deref Trait to use.\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n")),(0,r.kt)("h3",{id:"implicit-deref-coercion"},"Implicit Deref Coercion"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Deref coercion")," is a convenience feature that converts one Reference to another (ex ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"). Because String implements the Deref trait such, that it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.kt)("p",null,"Deref coercion was added to Rust so that programmers writing function and method calls don\u2019t need to add as many explicit references and dereferences with ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"*")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn test(name: &str) {\n    println!("{name}");\n}\nfn main() {\n    let m = MyBox::new(String::from("Rust"));\n\n    // instead of having to write the full casting like this:\n    test(&(*m)[..]);\n\n    // deref coercion allows us to just write:\n    test(&m)\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"(*m)")," dereferences the ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBox<String>")," into a String. Then the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[..]")," take a string slice of the String that is equal to the whole string to match the signature of hello. This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically."),(0,r.kt)("p",null,"When the Deref trait is involved, Rust will use the deref function as many times as necessary to get a reference to match the parameters type."),(0,r.kt)("h2",{id:"drop-trait"},"Drop Trait"),(0,r.kt)("h3",{id:"running-code-on-cleanup-with-the-drop-trait"},"Running Code on Cleanup with the Drop Trait"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," lets us customize what happens when a value is about to go out of scope. For example when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," goes out of scope it will deallocate the space on the heap, the box points to."),(0,r.kt)("p",null,"This way no memory will leak. The following example will print out whenever an instance of our CustomPointer goes out of scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'struct CustomSmartPointer {\n    data: String,\n}\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!("Dropping CustomSmartPointer with data `{}`!", self.data);\n        // this is where one could implement cleanup functionality\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from("first pointer"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from("second blah blah"),\n    };\n    println!("CustomSmartPointers created.");\n}\n')),(0,r.kt)("h3",{id:"dropping-a-value-early"},"Dropping a Value Early"),(0,r.kt)("p",null,"Rust does not allow us to call the drop function manually. This could be neccessary when implementing Smartpointers for a lock and unlock functionality for multithreading. "),(0,r.kt)("p",null,"Instead we have to use ",(0,r.kt)("inlineCode",{parentName:"p"},"std::mem::drop")," to release the lock so that other code in the same scope can aquire the lock."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let c = CustomSmartPointer {\n        data: String::from("some data"),\n    };\n    println!("CustomSmartPointer created.");\n    //c.drop();     // this is not allowed \n    drop(c);\n    println!("CustomSmartPointer dropped before the end of main.");\n}\n')))}m.isMDXComponent=!0}}]);