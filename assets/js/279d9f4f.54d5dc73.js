"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[7336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,f=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={},o="OOP in Rust - Object-Oriented paradigms in Rust",l={unversionedId:"rust/11OOP",id:"rust/11OOP",title:"OOP in Rust - Object-Oriented paradigms in Rust",description:"Inheritance",source:"@site/docs/rust/11OOP.md",sourceDirName:"rust",slug:"/rust/11OOP",permalink:"/md/rust/11OOP",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/11OOP.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Smart Pointers in Rust",permalink:"/md/rust/10smartpointers"},next:{title:"Basic Examples",permalink:"/md/rust/examples/01basic"}},s={},u=[{value:"Inheritance",id:"inheritance",level:2},{value:"Polymorphism - Definiton:",id:"polymorphism---definiton",level:3},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Trait Objects that allow values of different Types",id:"trait-objects-that-allow-values-of-different-types",level:2},{value:"Differentiating the above from a generic-trait implementation",id:"differentiating-the-above-from-a-generic-trait-implementation",level:3},{value:"Example of a state pattern - state machine in Rust",id:"example-of-a-state-pattern---state-machine-in-rust",level:2},{value:"Mario state machine with Enums in Rust",id:"mario-state-machine-with-enums-in-rust",level:2}],p={toc:u};function m(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"oop-in-rust---object-oriented-paradigms-in-rust"},"OOP in Rust - Object-Oriented paradigms in Rust"),(0,r.kt)("h2",{id:"inheritance"},"Inheritance"),(0,r.kt)("p",null,"Rust has no real inheritance (by design). Instead you could:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"use Traits with default implementation."),(0,r.kt)("li",{parentName:"ul"},"use generics to enable Polymorphism.")),(0,r.kt)("h3",{id:"polymorphism---definiton"},"Polymorphism - Definiton:"),(0,r.kt)("p",null,"Code that can work with mdata of multiple types. (ex Generics in Rust)"),(0,r.kt)("h2",{id:"encapsulation"},"Encapsulation"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pub")," keyword to define public vs automatically hidden/private details of the implementation. Default in Rust is usually to be hidden."),(0,r.kt)("p",null,"The following example for example encapsulates the actual implementation of the List away. That way it would be easy to change from a Vec to a HashSet etc at a later point, without changing anything that uses the AveragedCollection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct AveragedCollection {\n    // private fields\n    list: Vec<i32>,\n    average: f64,\n}\n\nimpl AveragedCollection {\n    // only public methods exposed to the outside are:\n    // - add(), remove(), and average().\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            }\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n")),(0,r.kt)("h2",{id:"trait-objects-that-allow-values-of-different-types"},"Trait Objects that allow values of different Types"),(0,r.kt)("p",null,"Example to implement a Draw Trait, to enable our theoretical GUI to render out or data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// the Draw trait, that \'makes sure\' that we are able to draw everything that implements it.\npub trait Draw{\n    fn draw(&self);\n}\n\n// components holds all our Components. \n// - In a Box because Vec is fixed size -> we just hold the pointer\n// - dyn Draw is the \'stand in\' for anyt type that implements the Draw trait.\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n// We implement the Run method that draws all components:\nimpl Screen{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\n// now we can implement the Trait on a few examples:\n#[derive(Debug)]\npub struct Button {\n    width: u32,\n    height: u32,\n    label: String,\n}\nimpl Draw for Button {\n    fn draw(&self) {\n        println!("Button: {:?}",self.label)\n    }\n}\n\npub struct SelectBox{\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!("Select Box:");\n        for o in self.options.iter() {\n            println!("     [x] - {}", &o);\n        }\n    }\n}\n\n// this is how it could be used:\nfn main() {\n    let b1 = Button{\n        width: 10,\n        height: 10,\n        label: String::from("Click me"),\n    };\n    let b2 = Button{\n        width: 10,\n        height: 10,\n        label: String::from("Submit"),\n    };\n    let sbox = SelectBox{\n        width: 10,\n        height: 30,\n        options: vec![\n            String::from("Yes"),\n            String::from("Maybe"),\n            String::from("No"),\n        ],\n    };\n    let screen = Screen{\n        components: vec![Box::new(b1), Box::new(sbox), Box::new(b2), ],\n    };\n    screen.run();\n}\n// -> Button: "Click me"\n// -> Select Box:\n// ->      [x] - Yes\n// ->      [x] - Maybe\n// ->      [x] - No\n// -> Button: "Submit"\n')),(0,r.kt)("h3",{id:"differentiating-the-above-from-a-generic-trait-implementation"},"Differentiating the above from a generic-trait implementation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We could also do something similar with generics:"),(0,r.kt)("li",{parentName:"ul"},"this has some limitations and benifits though: ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Every component in the Screen MUST be of the same type in this case (so only button etc.)"),(0,r.kt)("li",{parentName:"ul"},"BUT this 2nd implementation will use ",(0,r.kt)("strong",{parentName:"li"},"static dispatch"),". So it will not have any run time cost attatched to it. The dynamic ",(0,r.kt)("inlineCode",{parentName:"li"},"<Box<dyn Draw>>")," implementation above on the other hand will have the additional runtime cost of checking types at runtime. Called ",(0,r.kt)("strong",{parentName:"li"},"dynamic dispatch")," in rust.")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n")),(0,r.kt)("h2",{id:"example-of-a-state-pattern---state-machine-in-rust"},"Example of a state pattern - state machine in Rust"),(0,r.kt)("p",null,"Functionality should include:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"- blog starts as an empty draft\n- after a draft is done, a review is requested.\n- when the post is approved it gets published\n- only published posts are allowed to return content in `.content()`. \n")),(0,r.kt)("p",null,"Any other changes attempted should have no effect."),(0,r.kt)("p",null,"3 Solutions could solve this problem:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"using dyn-Box: ",(0,r.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html#implementing-an-object-oriented-design-pattern"},"https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html#implementing-an-object-oriented-design-pattern"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"runtime checking, have to implement methods multiple times etc. (check macros for shortcutting this)"),(0,r.kt)("li",{parentName:"ul"}))),(0,r.kt)("li",{parentName:"ul"},"using enums for the different Post-Types",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Must exhause all cases every time (ex use match-Statement etc.)"))),(0,r.kt)("li",{parentName:"ul"},"Encoding States and Behavior as Types: ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"this is the most strict implementation post.content() will not compile before it is accessible.")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut post = Post::new();                                 // -> post is: DrafPost\n    post.add_text("Some Content for a well written Blog...");   // -> post.content becomes "Some Content..."\n    let post = post.request_review();                           // -> post is: PendingReviewPost\n    let post = post.approve();                                  // -> post is: Post\n    assert_eq!("Some Content for a well written Blog...", post.content());\n}\npub struct Post {\n    content: String,\n}\npub struct DraftPost {\n    content: String,\n}\npub struct PendingReviewPost {\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> DraftPost {\n        DraftPost { content: String::new(), }\n    }\n    pub fn content(&self) -> &str {\n        &self.content\n    }\n}\nimpl DraftPost {\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n    pub fn request_review(self) -> PendingReviewPost{\n        PendingReviewPost{ content: self.content, }\n    }\n}\nimpl PendingReviewPost {\n    pub fn approve(self) -> Post {\n        Post {content: self.content, }\n    }\n}\n')),(0,r.kt)("h2",{id:"mario-state-machine-with-enums-in-rust"},"Mario state machine with Enums in Rust"),(0,r.kt)("p",null,"Finite State machine that implements Mario-Game's Mushrooms logic:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Mario states ",src:n(1240).Z,width:"454",height:"356"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Small Mario"),(0,r.kt)("li",{parentName:"ul"},"Super Mario"),(0,r.kt)("li",{parentName:"ul"},"Fire Mario"),(0,r.kt)("li",{parentName:"ul"},"Cape Mario")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, PartialEq)]\nenum State {\n    SmallMario,\n    SuperMario,\n    FireMario,\n    CapeMario,\n}\nenum Upgrade {\n    Mushroom,\n    Flower,\n    Feather,\n} \nstruct Player {\n    state: State,\n    //...\n}\nuse State::*;\nuse Upgrade::*;\n\nimpl Player {\n    fn new() -> Self {\n        Self { state: SmallMario}   // default state we start with\n    }\n    fn collect(&mut self, power: Upgrade) {\n        match (&self.state, power) {\n            (SmallMario, Mushroom)  => self.state = SuperMario,\n            (_,         Flower)     => self.state = FireMario,\n            (_,         Feather)    => self.state = CapeMario,\n            (_,         Mushroom)   => {},      // no change here\n        }\n    }\n}\n\nfn main() {\n    let mut mario = Player::new();\n    assert_eq!(mario.state, SmallMario);\n    mario.collect(Mushroom);\n    assert_eq!(mario.state, SuperMario);\n    mario.collect(Flower);\n    assert_eq!(mario.state, FireMario);\n    mario.collect(Feather);\n    assert_eq!(mario.state, CapeMario);\n    mario.collect(Mushroom);\n    assert_eq!(mario.state, CapeMario);\n}\n")))}m.isMDXComponent=!0},1240:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mario-states-b70d174f7b708339455346d1c5a6ba83.svg"}}]);