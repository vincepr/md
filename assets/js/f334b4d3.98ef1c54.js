"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[5333],{3905:(e,n,t)=>{t.d(n,{Zo:()=>k,kt:()=>y});var a=t(7294);function c(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){c(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,c=function(e,n){if(null==e)return{};var t,a,c={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(c[t]=e[t]);return c}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(c[t]=e[t])}return c}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},k=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},T="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,c=e.mdxType,o=e.originalType,l=e.parentName,k=i(e,["components","mdxType","originalType","parentName"]),T=s(t),u=c,y=T["".concat(l,".").concat(u)]||T[u]||d[u]||o;return t?a.createElement(y,r(r({ref:n},k),{},{components:t})):a.createElement(y,r({ref:n},k))}));function y(e,n){var t=arguments,c=n&&n.mdxType;if("string"==typeof e||c){var o=t.length,r=new Array(o);r[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[T]="string"==typeof e?e:c,r[1]=i;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5389:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>T,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=t(7462),c=(t(7294),t(3905));const o={},r="Token Caching ideas",i={unversionedId:"csharp/examples/TokenCachingGeneric",id:"csharp/examples/TokenCachingGeneric",title:"Token Caching ideas",description:"TokenCachingGeneric - multiple key-token-pairs to cache",source:"@site/docs/csharp/examples/TokenCachingGeneric.md",sourceDirName:"csharp/examples",slug:"/csharp/examples/TokenCachingGeneric",permalink:"/md/csharp/examples/TokenCachingGeneric",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/csharp/examples/TokenCachingGeneric.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pattern Matching in Csharp",permalink:"/md/csharp/examples/PatternMatching"},next:{title:"Yield in csharp",permalink:"/md/csharp/examples/Yield"}},l={},s=[{value:"TokenCachingGeneric - multiple key-token-pairs to cache",id:"tokencachinggeneric---multiple-key-token-pairs-to-cache",level:3},{value:"Token Caching with refresh Token",id:"token-caching-with-refresh-token",level:3}],k={toc:s};function T(e){let{components:n,...t}=e;return(0,c.kt)("wrapper",(0,a.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("h1",{id:"token-caching-ideas"},"Token Caching ideas"),(0,c.kt)("h3",{id:"tokencachinggeneric---multiple-key-token-pairs-to-cache"},"TokenCachingGeneric - multiple key-token-pairs to cache"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},"some ideas about token caching since IMemoryCache sucks")),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-csharp"},'using System.Collections.Concurrent;\nusing System.Net;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace TestProject1;\n\npublic class MyToken : IToken\n{\n    public string AccessToken { get; init; }\n    public DateTimeOffset ExpiresAt { get; init; }\n    public bool IsExpired() => DateTimeOffset.UtcNow >= ExpiresAt.AddSeconds(10);\n}\n\npublic class MyTokenClient : ITokenClient<MyToken, string>\n{\n    public Task<MyToken> GetTokenAsync(string key, CancellationToken cancellationToken = default) => Task.FromResult(new MyToken\n    {\n        AccessToken = "hello",\n        ExpiresAt = DateTimeOffset.UtcNow.AddHours(2),\n    });\n}\n\npublic static class Exteionsion\n{\n    public static void AddTokenStore(IServiceCollection services)\n    {\n        services.AddSingleton<ITokenClient<MyToken, string>, MyTokenClient>();\n        services.AddSingleton<ITokenStore<MyToken, string>, TokenCache<MyToken, string>>();\n    }\n}\n\npublic class MyDelegatingHandler : DelegatingHandler\n{\n    private readonly ITokenStore<MyToken, string> _tokenStore;\n    \n    public MyDelegatingHandler(ITokenStore<MyToken, string> tokenStore)\n    {\n        _tokenStore = tokenStore;\n    }\n    \n    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        request.Headers.TryGetValues("SellerId", out var headers);\n        var sellerId = headers!.Single();\n        request.Headers.Add("Bearer", (await _tokenStore.GetTokenAsync(sellerId, cancellationToken)).AccessToken);\n        \n        var response =  await base.SendAsync(request, cancellationToken);\n        if (response.StatusCode == HttpStatusCode.Unauthorized || response.StatusCode == HttpStatusCode.Forbidden)\n        {\n            // here we can do retry handling / if token gets bad before ExpiresAt then we MUST invalidate here aswell:\n            await _tokenStore.ForceTokenRefreshAsync(sellerId, cancellationToken);\n        }\n\n        return response;\n    }\n}\n\n// interfaces\npublic interface ITokenStore<TToken, TKey>\n{\n    Task<TToken> GetTokenAsync(TKey key, CancellationToken cancellationToken = default);\n    Task<TToken> ForceTokenRefreshAsync(TKey key, CancellationToken cancellationToken = default);\n    Task<TToken[]> GetCredentialsAsync(IEnumerable<TKey> ids, CancellationToken token = default);\n}\n\npublic interface IToken\n{\n    public bool IsExpired();\n}\n\npublic interface ITokenClient<TToken, TKey>\n{\n    public Task<TToken> GetTokenAsync(TKey key, CancellationToken cancellationToken = default);\n}\n\n// generic does the heavy lifting\n// we are able to ensure we only fetch every \'token\' once. For each id, Ex different accounts.\n//\npublic class TokenCache<TToken, TKey> : ITokenStore<TToken, TKey> where TKey : notnull where TToken : class, IToken\n{\n    private record CacheEntry\n    {\n        public required SemaphoreSlim Lock { get; init; }\n        public required TToken? Entry { get; set; }\n    }\n    private readonly ConcurrentDictionary<TKey, CacheEntry> _cache = new();\n    // to avoid any race condition when creating new cache-entries we lock for it. We could also seed our ConcurrentDictionary instead.\n    private readonly SemaphoreSlim _cacheCreationLock = new (1,1);\n    private readonly ITokenClient<TToken, TKey> _tokenClient;\n\n    public TokenCache(ITokenClient<TToken, TKey> tokenClient)\n    {\n        _tokenClient = tokenClient;\n    }\n\n    public async Task<TToken> GetTokenAsync(TKey key, CancellationToken cancellationToken = default)\n    {\n        if (!_cache.TryGetValue(key, out var cachedElement))\n        {\n            await _cacheCreationLock.WaitAsync(cancellationToken);\n            try\n            {\n                cachedElement = _cache.GetOrAdd(key, new CacheEntry\n                {\n                    Lock = new SemaphoreSlim(1, 1),\n                    Entry = null\n                });\n            }\n            finally\n            {\n                _cacheCreationLock.Release();\n            }\n        }\n        \n        if (cachedElement.Entry is not null && !cachedElement.Entry.IsExpired())\n        {\n            return cachedElement.Entry;\n        }\n\n        await cachedElement.Lock.WaitAsync(cancellationToken);\n        try\n        {\n            // check if while we were locked someone else initialized the token:\n            if (cachedElement.Entry is not null && !cachedElement.Entry.IsExpired())\n            {\n                return cachedElement.Entry;\n            }\n            \n            // initialize token for the first time:\n            cachedElement.Entry = await _tokenClient.GetTokenAsync(key, cancellationToken);\n            return cachedElement.Entry;\n        }\n        finally\n        {\n            cachedElement.Lock.Release();\n        }\n    }\n    public async Task<TToken> ForceTokenRefreshAsync(TKey key, CancellationToken cancellationToken)\n    {\n        var cachedElement = await CachedElement(key, cancellationToken);\n        \n        await cachedElement.Lock.WaitAsync(cancellationToken);\n        try\n        {\n            cachedElement.Entry = await _tokenClient.GetTokenAsync(key, cancellationToken);\n            return cachedElement.Entry;\n        }\n        finally\n        {\n            cachedElement.Lock.Release();\n        }\n    }\n\n    // we create empty Dictionary entry if if Cached-Element does not already exist: \n    private async Task<CacheEntry> CachedElement(TKey key, CancellationToken cancellationToken)\n    {\n        if (_cache.TryGetValue(key, out var cachedElement))\n        {\n            return cachedElement;\n        }\n        \n        await _cacheCreationLock.WaitAsync(cancellationToken);\n        try\n        {\n            cachedElement = _cache.GetOrAdd(key, new CacheEntry\n            {\n                Lock = new SemaphoreSlim(1, 1),\n                Entry = default\n            });\n            return cachedElement;\n        }\n        finally\n        {\n            _cacheCreationLock.Release();\n        }\n    }\n\n    public async Task<TToken[]> GetCredentialsAsync(IEnumerable<TKey> ids, CancellationToken token = default)\n    {\n        var tasks = ids.Select(id => GetTokenAsync(id, token));\n        return await Task.WhenAll(tasks);\n    }\n}\n')),(0,c.kt)("h3",{id:"token-caching-with-refresh-token"},"Token Caching with refresh Token"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-csharp"},'// interfaces\npublic interface ITokenCache\n{\n    Task<MyToken> GetTokenAsync(string key, CancellationToken cancellationToken = default);\n    Task<MyToken> ForceTokenRefreshAsync(string key, CancellationToken cancellationToken = default);\n    Task<MyToken[]> GetMultTokensAsync(IEnumerable<string> ids, CancellationToken token = default);\n}\n\npublic interface IToken\n{\n    public bool IsExpired();\n}\n\npublic class MyToken : IToken\n{\n    public required string AccessToken { get; init; }\n    public required DateTimeOffset ExpiresAt { get; init; }\n    public bool IsExpired() => DateTimeOffset.UtcNow >= ExpiresAt.AddSeconds(10);\n}\n\n\npublic interface IRefreshTokenProvider\n{\n    public Task<RefreshToken> GetTokenAsync(string key, CancellationToken cancellationToken = default);\n}\n\npublic record RefreshToken : IToken\n{\n    public required string TokenString { get; init; }\n    public required DateTimeOffset ExpiresAt { get; init; }\n    public bool IsExpired() => DateTimeOffset.UtcNow >= ExpiresAt.AddSeconds(10);\n}\n\npublic interface ITokenClient<TToken, TKey>\n{\n    public Task<TToken> GetTokenAsync(TKey key, CancellationToken cancellationToken = default);\n}\n\npublic class TokenCache : ITokenCache\n{\n    // to avoid any race condition when creating new cache-entries we lock for it. We could also seed our ConcurrentDictionary instead.\n    private readonly SemaphoreSlim _cacheCreationLock = new (1,1);\n    private readonly ConcurrentDictionary<string, (SemaphoreSlim IndividualLock, MyToken? Token)> _cache = new(); \n    private readonly IRefreshTokenProvider _refreshProvider;\n    private readonly ITokenClient<MyToken, RefreshToken> _tokenClient;\n\n    public TokenCache(ITokenClient<MyToken, RefreshToken> tokenClient, IRefreshTokenProvider refreshProvider)\n    {\n        _tokenClient = tokenClient;\n        _refreshProvider = refreshProvider;\n        // // alt way of seeding the _cache. Then whole _cacheCreatingLock and FindAccountOrCreate() can be removed with _cache[key].\n        // _cache = new(\n        //     [\n        //         new("normal", (new SemaphoreSlim(1, 1), null)),\n        //         new("deluxe", (new SemaphoreSlim(1, 1), null)),\n        //     ]);\n    }\n\n    /// <summary>\n    /// Gets token from cache if exists. Gets new from AuthApi if not found or IsExpired.\n    /// </summary>\n    public async Task<MyToken> GetTokenAsync(string key, CancellationToken cancellationToken = default)\n    {\n        var cachedAccount = await FindAccountOrCreate(key, cancellationToken);\n        \n        if (cachedAccount.Token is not null && !cachedAccount.Token.IsExpired())\n        {\n            return cachedAccount.Token;\n        }\n\n        await cachedAccount.IndividualLock.WaitAsync(cancellationToken);\n        try\n        {\n            // some other process might have already refreshed while we were stuck in lock:\n            if (cachedAccount.Token is not null && !cachedAccount.Token.IsExpired())\n            {\n                return cachedAccount.Token;\n            }\n            \n            // initialize token for the first time or take care of refreshing because it was expired:\n            cachedAccount.Token = await FetchAccessToken(key, cancellationToken);\n            return cachedAccount.Token;\n        }\n        finally\n        {\n            cachedAccount.IndividualLock.Release();\n        }\n    }\n\n    /// <summary>\n    /// Always gets new Token from AuthApi. Writes it to cache and returns Token.\n    /// </summary>\n    public async Task<MyToken> ForceTokenRefreshAsync(string key, CancellationToken cancellationToken)\n    {\n        var cachedAccount = await FindAccountOrCreate(key, cancellationToken);\n        \n        await cachedAccount.IndividualLock.WaitAsync(cancellationToken);\n        try\n        {\n            cachedAccount.Token = await FetchAccessToken(key, cancellationToken);\n            return cachedAccount.Token;\n        }\n        finally\n        {\n            cachedAccount.IndividualLock.Release();\n        }\n    }\n    \n    // all awaiting and token fetching happens in here. Should only happen in a locked state for that IndividualKey:\n    private async Task<MyToken> FetchAccessToken(string key, CancellationToken cancellationToken)\n    {\n        var refreshToken = await _refreshProvider.GetTokenAsync(key, cancellationToken);\n        return await _tokenClient.GetTokenAsync(refreshToken, cancellationToken);\n    }\n\n    // we create empty Dictionary entry if if Cached-Element does not already exist: \n    private async Task<(SemaphoreSlim IndividualLock, MyToken? Token)> FindAccountOrCreate\n        (string key, CancellationToken cancellationToken)\n    {\n        if (_cache.TryGetValue(key, out var cachedElement))\n        {\n            return cachedElement;\n        }\n        \n        await _cacheCreationLock.WaitAsync(cancellationToken);\n        try\n        {\n            cachedElement = _cache.GetOrAdd(key, (new SemaphoreSlim(1,1), null));\n            return cachedElement;\n        }\n        finally\n        {\n            _cacheCreationLock.Release();\n        }\n    }\n\n    public async Task<MyToken[]> GetMultTokensAsync(IEnumerable<string> ids, CancellationToken token = default)\n    {\n        var tasks = ids.Select(id => GetTokenAsync(id, token));\n        return await Task.WhenAll(tasks);\n    }\n}\n\n')))}T.isMDXComponent=!0}}]);