"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[7758],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,f=d["".concat(s,".").concat(m)]||d[m]||c[m]||l;return t?a.createElement(f,i(i({ref:n},p),{},{components:t})):a.createElement(f,i({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9129:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=t(7462),r=(t(7294),t(3905));const l={},i="Basic structures",o={unversionedId:"datastructures/dynamic_array",id:"datastructures/dynamic_array",title:"Basic structures",description:"The basic struct most other structs are made out of",source:"@site/docs/datastructures/dynamic_array.md",sourceDirName:"datastructures",slug:"/datastructures/dynamic_array",permalink:"/md/datastructures/dynamic_array",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/datastructures/dynamic_array.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Union Find - Disjoint Set",permalink:"/md/datastructures/disjoined_set"},next:{title:"Hash Table - Hash Map",permalink:"/md/datastructures/hashtable"}},s={},u=[{value:"Static Array vs Dynamic Array",id:"static-array-vs-dynamic-array",level:2},{value:"Static Array",id:"static-array",level:3},{value:"Dynamic Array",id:"dynamic-array",level:3},{value:"Implementation Dynamic Array in C",id:"implementation-dynamic-array-in-c",level:2},{value:"Implementation Dynamic Array in Rust",id:"implementation-dynamic-array-in-rust",level:2}],p={toc:u};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"basic-structures"},"Basic structures"),(0,r.kt)("p",null,"The basic struct most other structs are made out of"),(0,r.kt)("h2",{id:"static-array-vs-dynamic-array"},"Static Array vs Dynamic Array"),(0,r.kt)("h3",{id:"static-array"},"Static Array"),(0,r.kt)("p",null,"Continous chunk of memory. To reserve/allocate the memory the size has to be known at time of creation."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"This means they can be allocated on the stack (if whatever we store is fixed size). So really fast"),(0,r.kt)("li",{parentName:"ul"},"Modern CPU's are also really good at Cashing, so consecutive access to the same array can be really fast that way.")),(0,r.kt)("h3",{id:"dynamic-array"},"Dynamic Array"),(0,r.kt)("p",null,"Extension of a Statc Array but, gets reallocated once full (or if it shrinks enough)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Access"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,r.kt)("td",{parentName:"tr",align:null},"can index directly into")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Search"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"worst case whole array gets run trough")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Insertion"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"worst case we insert at idx=0 so we have to shift everything right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Appending"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,r.kt)("td",{parentName:"tr",align:null},"really fast to ",(0,r.kt)("inlineCode",{parentName:"td"},"push()")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"pop()"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deletion"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,r.kt)("td",{parentName:"tr",align:null},"worst case we delete idx=0 so we have to shift everything left")))),(0,r.kt)("h2",{id:"implementation-dynamic-array-in-c"},"Implementation Dynamic Array in C"),(0,r.kt)("p",null,"First we take care of memory allocation with some generic macros:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"memory.h"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#ifndef custom_memory_h\n#define custom_memory_h\n\n// macro that allocates an array with given type and count/size:\n#define ALLOCATE(type, count) \\\n    (type*)reallocate(NULL, 0, sizeof(type) * (count))\n\n// macro - used to free memory that a custom Object used\n#define FREE(type, pointer) reallocate(pointer, sizeof(type), 0)\n\n// We define we double Capacity whenever we reach its limit\n// - we start at 8 (after upgrade from when it gets initialized with capacity = 0)\n// - afterwards we double each time 8 -> 16 -> 32 -> 64 -> 128....\n#define GROW_CAPACITY(capacity) \\\n    ((capacity) < 8 ? 8 : (capacity) * 2)\n\n// This macro calls reallocate with newSize=0 -> so it will get deleted from memory there\n#define FREE_ARRAY(type, pointer, oldCount) \\\n    reallocate(pointer, sizeof(type) * (oldCount), 0);\n\nvoid* reallocate(void* pointer, size_t oldSize, size_t newSize);\n#endif\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"memory.c"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include "memory.h"\n\n//  The single function used for all dynamic memory management\n    // if   -oldSize-   -newSize-       -then do Operation:-\n    //      0           Non-zero        Allocate new block-\n    //      Non-Zero    0               Free allocation.\n    //      Non-Zero    new<oldSize     Shrink existing allocation.\n    //      Non-Zero    new>oldSize     Grow existing allocation.\nvoid* reallocate(void* pointer, size_t oldSize, size_t newSize) {\n    if (newSize == 0) {\n        free(pointer);\n        return NULL;\n    }\n\n    void* result = realloc(pointer, newSize);\n    if (result == NULL) exit(1);                // We must handle the case of realloc failing (ex. not enough free memory left on OS)\n    return result;\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"array.h"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#ifndef custom_array_h\n#define custom_array_h\n\ntypedef struct {\n    int capacity;\n    int count;\n    Int* values;    // pointer to our static-array\n} IntArray;\n\nvoid initIntArray(IntArray* array);\nvoid pushToArray(IntArray* array, int value);\nvoid deleteFromArray(IntArray* array, int index);\nvoid freeIntArray(IntArray* array);\n\n\n#endif\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"array.c"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include "memory.h"\n#include "varray.h"\n\n// inititializing the dynamic data structure\nvoid initIntArray(IntArray* array) {\n    array->values = NULL;\n    array->capacity = 0;\n    array->count = 0;\n}\n\n// appends new value to array, if full it reallocates to double\'d size\nvoid pushToArray(IntArray* array, int value) {\n    if (array->capacity < array->count + 1) {\n        int oldCapacity = array->capacity;\n        array->capacity = GROW_CAPACITY(oldCapacity);\n        array->values = GROW_ARRAY(Value, array->values, oldCapacity, array->capacity);\n    }\n    array->values[array->count] = value;\n    array->count++;\n}\n\n// deletes at idx specified\nvoid deleteFromArray(IntArray* array, int index) {\n    for (int i = index; i < array->count -1; i++) {\n        array->items[i] = array->items[i+1];\n    }\n    array->items[array->count-1] = NULL;    // cleanup the memory were not using anymore\n    array->count--;\n}\n\n// after done we have to manually malloc the memory\nvoid freeIntArray(IntArray* array) {\n    FREE_ARRAY(Int, array->values, array->capacity);\n    initIntArray(array);\n}\n\nvoid arrayWriteToIdx(IntArray* array, int index, int value) {\n    array->items[index] = value;\n}\n\nint arrayReadFromIdx() {\n    return array->values[index]\n}\n\nbool isValidIndex(IntArray* array, int index) {\n    return (index >= 0 && index < array->count)\n}\n\nint arrayGetLength(IntArray* array) {\n    return array->count;\n}\n')),(0,r.kt)("h2",{id:"implementation-dynamic-array-in-rust"},"Implementation Dynamic Array in Rust"),(0,r.kt)("p",null,"Rustnomicon-Book on the full unsafe guide for rust. Definitly gotta read that book when i have the time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use std::{mem, ptr::NonNull, alloc::Layout};\n\nfn main() {\n    let mut arr:Array<&str> = Array::new();\n    arr.push(\"Hello\");\n    arr.push(\"World\");\n    arr.push(\"1\");\n    arr.push(\"16\");\n    dbg!(&arr[0]);\n    dbg!(&arr[1]);\n    dbg!(&arr[3]);\n\n\n}\n\n#[derive(Debug)]\n/// dynamic Array implementation - of note: Vec is already mostly what were building, so this is more a theoretical practice thing\npub struct Array<T> {\n    buf: RawArray<T>,\n    len: usize,\n}\n\nimpl<T> Array<T> {\n    /// just forwards our pointer from our RawArray\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }\n\n    /// just forwards our capacity from our RawArray\n    fn cap(&self) -> usize {\n        self.buf.cap\n    }\n    \n    /// initializes the Array struct. BUT first allocation on the heap has not happened. (only when filled)\n    pub fn new() -> Self {\n        Array {\n           buf: RawArray::new(),\n            len: 0,\n        }\n    }\n\n    /// pushes the element on top of the Array.\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap() {self.buf.grow(); }\n        unsafe {\n            std::ptr::write(self.ptr().add(self.len), elem);\n        }\n        self.len += 1;\n    }\n\n    /// pops top element from Array, if it exists.\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -=1;\n            unsafe {\n                // ptr::read() copies the bits from adress and interprets it as T. \n                // we offset by self.len to get to the top of the stack\n                Some(std::ptr::read(self.ptr().add(self.len)))\n            }\n        }\n    }\n\n    /// insert and shift to right if not inserting at top\n    /// - we use ptr::copy == C's memmove -> copies a chunk of memory \n    pub fn insert(&mut self, index: usize, elem: T) {\n        assert!(index <= self.len, \"index is out of bounds.\");\n        if self.cap() == self.len { self.buf.grow(); }\n        unsafe {\n            // first we copy everything at the idx one idx to the right\n            std::ptr::copy(\n                self.ptr().add(index),\n                self.ptr().add(index - 1),\n                self.len - index,\n            );\n            // then we insert our new element at the index\n            std::ptr::write(self.ptr().add(index), elem);\n            self.len += 1;\n        }\n    }\n\n    /// removes one element and shifts to left if there was something above it\n    /// - we use ptr::copy == C's memmove -> copies a chunk of memory \n    pub fn remove(&mut self, index: usize) -> T {\n        assert!(index < self.len, \"index is out of bounds.\");\n        unsafe {\n            self.len -=1;\n            let result = std::ptr::read(\n                self.ptr().add(index));\n            std::ptr::copy(\n                self.ptr().add(index +1),\n                self.ptr().add(index),\n                self.len - index,\n            );\n            return result;\n        }\n    }\n}\n\nimpl <T> Drop for Array<T> {\n    /// Drop trait - destructor that cleans up . we just do pop() till empty\n    /// - Drop implementation for RawArray handles the Deallocation\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}   // loop till empty\n    }\n}\n\n// Deref to enable []- Syntax to rea values in the array. ex: 'dbg!(arr[1]);'\nimpl<T> std::ops::Deref for Array<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe {\n            std::slice::from_raw_parts(self.ptr(), self.len)\n        }\n    }\n}\n// Deref to enable []- Syntax to write to values in the array. ex: 'arr[1]=\"hello\";'\nimpl<T> std::ops::DerefMut for Array<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.ptr(), self.len)\n        }\n    }\n}\n\n\n\n\n\n// Note: 'iter' and 'iter_mut' we got automagically with Deref. But 'into_iter' and 'drain' not.\n// - (those consume the Array by-value and yield its elements value by value)\n// they get implemented as DoubleEnded Iterator -> with 2 pointers pointing to the ends.\n// - 'end' points AFTER the element it wants read next. 'start' points DIRECTLY at the element. (for clarity when done)\npub struct IntoIter<T> {\n    _buf: RawArray<T>,\n    start: *const T,\n    end: *const T,\n}\n\n// because IntoIter takes ownership it NEEDS to Drop to free it. (ex. elements that were not yielded)\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // only need to ensure all our elements get droped, RawArray buffer will clean up after itself\n        for _ in &mut *self {}\n    }\n}\n\nimpl<T> IntoIterator for Array<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> IntoIter<T> {\n        unsafe {\n            // need to use ptr::read to unsafely move the buf out (and we cant destructure it)\n            let buf = std::ptr::read(&self.buf);\n            let len = self.len;\n            mem::forget(self);\n\n\n            IntoIter {\n                start: buf.ptr.as_ptr(),\n                end: if buf.cap ==0 {\n                    buf.ptr.as_ptr()    // we can only offset/add off the pointer if something is allocated\n                } else {\n                    buf.ptr.as_ptr().add(len)\n                },\n                _buf: buf,\n            }\n        }\n    }\n\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    /// consumes next element in array - read out what next points to then increment next.\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None    // iterator is empty\n        } else {\n            unsafe {\n                let result = std::ptr::read(self.start);\n                self.start = self.start.offset(1);\n                Some(result)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n        (len, Some(len))\n    }\n}\n\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    /// consumes last element from array - end points to after what we want to read -> so we offset first then read \n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.start == self.end {\n            None    // iterator is empty\n        } else {\n            unsafe {\n                self.end = self.end.offset(-1);\n                let result = std::ptr::read(self.end);\n                Some (result)\n            }\n        }\n    }\n}\n\n// the pointer (and capacity) get abstracted out from Array.\n// - this way all the unsafe memory allocation gets decoupled/gathered in one spot.\n#[derive(Debug)]\nstruct RawArray<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}\n// by implementing Send/Sync ontop of the NonNull<T> pointer we get the same benefits of Unique<T>\n\nunsafe impl <T: Send> Send for RawArray<T> {}\nunsafe impl <T: Sync> Sync for RawArray<T> {}\n\nimpl<T> RawArray<T> {\n    fn new() -> Self {\n        assert!(mem::size_of::<T>() !=0, \"TODO: implement Zero size allocation\");\n        RawArray { \n            ptr: NonNull::dangling(), // like Unique<T> a wrapper over a raw pointer. (that cant be NULL and must be of type T)\n            cap: 0, \n        }\n    }\n    /// grow will take care of all the memory allocation happening\n    /// - will double size once capacity is reached\n    /// - if out of memory-error it will call system implemention to abort\n    fn grow(&mut self) {\n        const INITIALCAP:usize = 8;     // first time we grow above initial len=cap=0 we skipp to this.\n        let (new_cap, new_layout) = if self.cap==0 {\n            (INITIALCAP, Layout::array::<T>(INITIALCAP).unwrap()) // since len=cap=0 we need to start with some bigger value\n        } else {\n            let new_cap = 2 * self.cap;\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n        // ensure that the new allocation is inside what a 32 or 64bit system pointer can handle\n        // staying inside those sizes and the above Layouts shouldn never unwrap\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation to large\");\n\n        // depending if cap was 0 previous we first allocate or reallocate memory with bigger cap:\n        let new_ptr = if self.cap == 0 {\n            unsafe { std::alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as * mut u8;\n            unsafe { std::alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // if allocation fails (not enough free memory) new_ptr will be null -> we abort (not just exit)\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) =>p,\n            None => std::alloc::handle_alloc_error(new_layout), // calls system default no-memory-abort\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl <T> Drop for RawArray<T> {\n    /// Drop trait - destructor that cleans up -> in this case deallocates our memory\n    /// - if self.cap == 0 no allocation happened and we skip deallocation\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe{\n                std::alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}\n\n")))}d.isMDXComponent=!0}}]);