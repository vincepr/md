"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[5713],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>h});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),u=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=u(e.components);return r.createElement(p.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=u(t),c=a,h=m["".concat(p,".").concat(c)]||m[c]||d[c]||i;return t?r.createElement(h,o(o({ref:n},s),{},{components:t})):r.createElement(h,o({ref:n},s))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[m]="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1883:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var r=t(7462),a=(t(7294),t(3905));const i={},o="Priority Queue - (often implemented with a Heap)",l={unversionedId:"datastructures/priority_queue",id:"datastructures/priority_queue",title:"Priority Queue - (often implemented with a Heap)",description:"Similar to normal queue BUT items of higher priority come out first.",source:"@site/docs/datastructures/priority_queue.md",sourceDirName:"datastructures",slug:"/datastructures/priority_queue",permalink:"/md/datastructures/priority_queue",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/datastructures/priority_queue.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Linked List (Singly Linked List)",permalink:"/md/datastructures/linked_list"},next:{title:"Queue in Csharp",permalink:"/md/datastructures/queue"}},p={},u=[{value:"Heap (often used for priority queue)",id:"heap-often-used-for-priority-queue",level:2},{value:"Usage",id:"usage",level:2},{value:"Complexity",id:"complexity",level:2},{value:"Max-Heap Implementation (in go)",id:"max-heap-implementation-in-go",level:2},{value:"Min and Max Heap in Csharp",id:"min-and-max-heap-in-csharp",level:2}],s={toc:u};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"priority-queue---often-implemented-with-a-heap"},"Priority Queue - (often implemented with a Heap)"),(0,a.kt)("p",null,"Similar to normal queue BUT items of higher priority come out first."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"items need to be comparable for this. So the comparable data must be able to be sorted in some way.")),(0,a.kt)("h2",{id:"heap-often-used-for-priority-queue"},"Heap (often used for priority queue)"),(0,a.kt)("p",null,"a tree that satisfies the heap property. ",(0,a.kt)("inlineCode",{parentName:"p"},"If A is a parent of node B, then A is ordered with respect to B for all nodes A,B in the heap")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Ex. if A the parent then all children and it's children are smaller.")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"can be used to implement Dijkstra's Shortest Path Algorithm"),(0,a.kt)("li",{parentName:"ul"},"if we for example always want to the next best (or next worst) node",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Best First Search (BFS) often grab the next most promising node like this"))),(0,a.kt)("li",{parentName:"ul"},"used in Huffman coding (lossless data compression)"),(0,a.kt)("li",{parentName:"ul"},"Minimum Spaning Tree algorithms (MST)")),(0,a.kt)("h2",{id:"complexity"},"Complexity"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Construction"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Polling"),(0,a.kt)("td",{parentName:"tr",align:null},"O(log(n))")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Peeking"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Adding"),(0,a.kt)("td",{parentName:"tr",align:null},"O(log(n))")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Naive Removing"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"hash-table removing"),(0,a.kt)("td",{parentName:"tr",align:null},"O(log(n))")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Naive contains"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"hash-table contains"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)")))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A hashtable ontop of the Heap adds overhead but makes remove() and contains() faster")),(0,a.kt)("h2",{id:"max-heap-implementation-in-go"},"Max-Heap Implementation (in go)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// our processes we want to queue (bigger prio -> do first)\ntype Process struct{\n    prio int\n}\n\n// our heap structure (max heap in this case)\ntype Heap struct{\n    arr []Process\n}\n\n\n// public function to add a element to the heap\nfunc (h *Heap) Insert(proc Process){\n    h.arr =  append(h.arr, proc)\n    h.heapifyUp(len(h.arr)-1)\n}\n// bring heap back into heap-state after a Input()\n// does so by swapping with parent till uptop or not bigger anymore\nfunc (h *Heap)heapifyUp(idx int){\n    for h.arr[idx].prio > h.arr[parent(idx)].prio {         // while( node>parent )\n        h.swap(parent(idx), idx)\n        idx = parent(idx)\n    }\n}\n\n\n// public function to "pop()" the largest/root node\nfunc (h *Heap) Extract() (Process, error) {\n    length := len(h.arr) -1\n    if length < 0 {\n        return Process{}, fmt.Errorf("Heap is Empty, can not remove anything")\n    }\n    popElement := h.arr[0]\n    h.arr[0] = h.arr[length]    // swap last element to first\n    h.arr = h.arr[:length]      // remove last slice element (but does not reallocate in go if i understand correctly)\n\n    h.heapifyDown(0)            // start our sort-shuffle from index 0\n    return popElement, nil\n}\n// bring heap back into heap-state after a Extract()\n// does so by potentially swapping with bigger child, moving down till bottom/no more swap\nfunc (h *Heap)heapifyDown(idx int){\n    current := idx\n    last    := len(h.arr)-1\n    l, r    := left(idx), right(idx)\n    for l <= last {\n        if l == last {\n            current = l\n        } else if h.arr[l].prio > h.arr[r].prio{\n            current = l\n        } else {\n            current = r\n        }\n        if h.arr[idx].prio < h.arr[current].prio{\n            h.swap(idx, current)\n            idx = current\n            l, r = left(idx) , right(idx)\n        } else { return }\n    }\n}\n\n\n/*\n*   helpers\n*/\n\n// returns the equivalent parent/left/right node of our "thought off binary-tree"\nfunc parent(idx int) int {\n    return (idx -1) / 2\n}\n\nfunc left(idx int) int {\n    return 2*idx +1\n}\n\nfunc right(idx int) int {\n    return 2*idx +2\n}\n\nfunc (h *Heap)swap(i1 int, i2 int){\n    h.arr[i1], h.arr[i2] = h.arr[i2], h.arr[i1]\n}\n')),(0,a.kt)("h2",{id:"min-and-max-heap-in-csharp"},"Min and Max Heap in Csharp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"internal static class Example\n{\n    public static void Run()\n    {\n        {\n            Console.WriteLine(\"--- Example: MAX PRIORITY QUEUE ---\");\n            var max = new MaxPriorityQueue<int, char>();\n\n            max.Add(5, 'a');\n            max.Add(9, 'b');\n            max.Add(12, 'c');\n            max.Add(13, 'd');\n            max.Add(16, 'e');\n            max.Add(45, 'f');\n\n            foreach (var item in max) Console.WriteLine(item);\n\n            Console.WriteLine($\"Count: {max.Count}\");\n            for (int i = max.Count; i > 0; i--)\n            {\n                //var (_,value) = min.Pop();\n                Console.WriteLine(\"Out: \" + max.Pop());\n                Console.WriteLine($\"new Count: {max.Count}\");\n                //foreach (var item in min) Console.WriteLine(item);\n            }\n        }\n        {\n            Console.WriteLine(\"--- Example: MIN PRIORITY QUEUE ---\");\n            var min = new MinPriorityQueue<int, char>();\n\n            min.Add(5, 'a');\n            min.Add(9, 'b');\n            min.Add(12, 'c');\n            min.Add(13, 'd');\n            min.Add(16, 'e');\n            min.Add(45, 'f');\n\n            foreach (var item in min) Console.WriteLine(item);\n\n            Console.WriteLine($\"Count: {min.Count}\");\n            for (int i = min.Count; i > 0; i--)\n            {\n                //var (_,value) = min.Pop();\n                Console.WriteLine(\"Out: \" + min.Pop());\n                Console.WriteLine($\"new Count: {min.Count}\");\n                //foreach (var item in min) Console.WriteLine(item);\n            }\n        }\n    }\n}\n\npublic class MaxPriorityQueue<TPriority, TValue> : IEnumerable<KeyValuePair<TPriority, TValue>>\n{\n    /// <summary>\n    /// Even though we store it as an array-like form it is actually a Binary Tree. \n    /// </summary>\n    //           0 == root,\n    //          /        \\\n    //   1 == left     2 == right\n    //  /        \\        /       \\\n    // 3 left  4 right  5left    6 right\n\n    private protected List<KeyValuePair<TPriority, TValue>> _heap;\n\n    private protected IComparer<TPriority> _comparer;\n\n    public int Count => _heap.Count;\n\n    public MaxPriorityQueue() : this(Comparer<TPriority>.Default) { }\n\n    public MaxPriorityQueue(IComparer<TPriority> comparer)\n    {\n        _heap = new List<KeyValuePair<TPriority, TValue>>();\n        _comparer = comparer;\n    }\n\n\n    public void Add(TPriority priority, TValue value)\n    {\n        _heap.Add(new KeyValuePair<TPriority, TValue>(priority, value));\n        HeapifyUp(_heap.Count - 1);\n    }\n    public void Insert(params KeyValuePair<TPriority, TValue>[] values)\n    {\n        foreach (var value in values) Add(value.Key, value.Value);\n    }\n\n    // bring heap back into heap-state after Insert(). does so by swapping with parent till uptop or bigger no more\n    private void HeapifyUp(int idx)\n    {\n        while (Compare(idx, Parent(idx)))\n        {\n            Swap(Parent(idx), idx);\n            idx = Parent(idx);\n        }\n    }\n\n    public TValue? Peek() => (_heap.Count > 0) ? _heap[0].Value : default;\n\n    // pops the value with highest priority from our Priority queue\n    public (TValue? value, bool success) Pop()\n    {\n        int len = _heap.Count - 1;\n        if (len < 0) return (default(TValue), false);\n\n        // swap last element in place of removed first\n        var value = _heap[0].Value;\n        _heap[0] = _heap[len];\n        _heap.RemoveAt(len);\n        HeapifyDown(0);\n        return (value, true);\n    }\n\n    // bring heap back into heap-state after a Pop()\n    // does so by potentially swapping with bigger child, moving down till bottom/no more swap\n    private void HeapifyDown(int idx)\n    {\n        int current = idx;\n        int last = _heap.Count - 1;\n        var (left, right) = (Left(idx), Right(idx));\n        while (left <= last) {\n            if (left == last)\n                current = left;\n            else if (Compare(left, right))\n                current = left;\n            else\n                current = right;\n\n            if (_comparer.Compare(_heap[idx].Key, _heap[current].Key) < 0)\n            {\n                Swap(idx, current);\n                idx = current;\n                (left, right) = (Left(idx), Right(idx));\n            }\n            else return;\n        }\n    }\n\n    // helpers  - to 'translate' from array structure to binary tree representation it represents\n    private static int Parent(int idx) => (idx - 1) / 2;\n\n    private static int Left(int idx) => 2 * idx + 1;\n\n    private static int Right(int idx) => 2 * idx + 2;\n\n    private void Swap(int idx1, int idx2)\n        => (_heap[idx1], _heap[idx2]) = (_heap[idx2], _heap[idx1]);\n\n    private bool Compare(int idx1, int idx2)\n        => _comparer.Compare(_heap[idx1].Key, _heap[idx2].Key) > 0;\n\n    public IEnumerator<KeyValuePair<TPriority, TValue>> GetEnumerator()\n        => ((IEnumerable<KeyValuePair<TPriority, TValue>>)_heap).GetEnumerator();\n\n    IEnumerator IEnumerable.GetEnumerator()\n        => ((IEnumerable)_heap).GetEnumerator();\n}\n\npublic class MinPriorityQueue<TPriority, TValue> : MaxPriorityQueue<TPriority, TValue>\n{\n    // we just have to map -1 -> +1 && +1 -> -1 && 0 -> 0\n    // and we changed our MaxPriorityQueue to a MinPriorityQueue\n    // we do this by wrapping the Comparer and negating all comparisons.\n\n    private class InverseComparer : IComparer<TPriority>\n    {\n        private Comparer<TPriority> _originalComparer;\n\n        public InverseComparer(Comparer<TPriority> comparer)\n        {\n            this._originalComparer = comparer;\n        }\n\n        public int Compare(TPriority? x, TPriority? y)\n        {\n            return -_originalComparer.Compare(x, y);\n        }\n    }\n\n    public MinPriorityQueue() : base(new InverseComparer(Comparer<TPriority>.Default)) { }\n\n    public MinPriorityQueue(IComparer<TPriority> comparer)\n    {\n        _heap = new List<KeyValuePair<TPriority, TValue>>();\n        _comparer = new InverseComparer((Comparer<TPriority>)comparer);\n    }\n}\n")))}m.isMDXComponent=!0}}]);