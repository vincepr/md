"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[3734],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),o=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=o(e.components);return r.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=o(n),m=a,f=d["".concat(i,".").concat(m)]||d[m]||p[m]||s;return n?r.createElement(f,l(l({ref:t},c),{},{components:n})):r.createElement(f,l({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,l=new Array(s);l[0]=m;var u={};for(var i in t)hasOwnProperty.call(t,i)&&(u[i]=t[i]);u.originalType=e,u[d]="string"==typeof e?e:a,l[1]=u;for(var o=2;o<s;o++)l[o]=n[o];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8839:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>u,toc:()=>o});var r=n(7462),a=(n(7294),n(3905));const s={},l="structure related to data",u={unversionedId:"rust/04data",id:"rust/04data",title:"structure related to data",description:"structs",source:"@site/docs/rust/04data.md",sourceDirName:"rust",slug:"/rust/04data",permalink:"/md/rust/04data",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/04data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Ownership Principles",permalink:"/md/rust/03owernership"},next:{title:"nginx",permalink:"/md/settings/nginx"}},i={},o=[{value:"structs",id:"structs",level:2},{value:"Touple struct",id:"touple-struct",level:3},{value:"structs without any fields",id:"structs-without-any-fields",level:3},{value:"Enums",id:"enums",level:2}],c={toc:o};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"structure-related-to-data"},"structure related to data"),(0,a.kt)("h2",{id:"structs"},"structs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"if a struct instance is mutable, the whole thing is mutable. (cant specify certain fields only)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\nfn main() {\n    let mut user1 = User{\n        active: true,\n        username: String::from("Bob"),\n        email: String::from("bob@ross.wrong"),\n        sign_in_count: 0,\n    };\n    user1.email = String::from("bob@ross.gg");\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"writing a constructor there is a shorthand syntax. (using same arg- and field-name)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn build_user(email: String, username: String)-> User{\n    User{\n        active: true,\n        username,               // instead of username: username\n        email,\n        sign_in_count: 0,\n    }\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"short way to move (NOT COPY) a user and change some fields:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let user2 = User{\n    email: String::from("anotherBob@ross.us"),\n    ..user1                     // must be last\n};\n// user1 not usable anymore (UNLESS we would set email and username)\n')),(0,a.kt)("p",null,"as discussed in the Ownership chapter, we just moved the data and now user1 exists no longer. Thats because User struct includes 2 strings. If we had set both email and username, the other values would be copied over and user1 would still exist as a variable!"),(0,a.kt)("h3",{id:"touple-struct"},"Touple struct"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n")),(0,a.kt)("h3",{id:"structs-without-any-fields"},"structs without any fields"),(0,a.kt)("p",null,"unit-like structs without any fields hold no data. still useful since we can use traits on them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct AlwaysEqual;\nfn main(){\n    let subject = AlwaysEqual;\n}\n")),(0,a.kt)("h2",{id:"enums"},"Enums"),(0,a.kt)("p",null,"You can put any kind of data inside an enum variant: strings, numeric types or structs, even other enums..."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'enum IpAddrKind {\n    V4,\n    V6,\n}\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nlet test = IpAddrKind::V4;\nlet home = IpAddr {\n    kind: IpAddrKind::V4,\n    address: String::from("127.0.0.1"),\n};\n\nfn route(ip_kind: IpAddrKind) {}    // takes in any variant\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it is also possible to put data directly into each enum variant (so there is no need for an extra struct in this case):"),(0,a.kt)("li",{parentName:"ul"},"they can even have different data inside:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from("::1"));\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"there is a std implementation for ip in rust:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n\nlet localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\nlet localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n\nassert_eq!("127.0.0.1".parse(), Ok(localhost_v4));\nassert_eq!("::1".parse(), Ok(localhost_v6));\n\nassert_eq!(localhost_v4.is_ipv6(), false);\nassert_eq!(localhost_v4.is_ipv4(), true);\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"")))}d.isMDXComponent=!0}}]);