"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[3070],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=s(t),p=r,d=u["".concat(c,".").concat(p)]||u[p]||f[p]||i;return t?a.createElement(d,l(l({ref:n},m),{},{components:t})):a.createElement(d,l({ref:n},m))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=p;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[u]="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3509:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const i={},l="Makefiles - mostly for c",o={unversionedId:"tools/makefile",id:"tools/makefile",title:"Makefiles - mostly for c",description:"The basic Makefile",source:"@site/docs/tools/makefile.md",sourceDirName:"tools",slug:"/tools/makefile",permalink:"/md/tools/makefile",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/tools/makefile.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Git",permalink:"/md/tools/git"},next:{title:"Prototyping Tools",permalink:"/md/tools/prototyping"}},c={},s=[{value:"The basic Makefile",id:"the-basic-makefile",level:2},{value:"Pattern matching but still a basic Makefile",id:"pattern-matching-but-still-a-basic-makefile",level:2},{value:"A Proper Makefile",id:"a-proper-makefile",level:2}],m={toc:s};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"makefiles---mostly-for-c"},"Makefiles - mostly for c"),(0,r.kt)("h2",{id:"the-basic-makefile"},"The basic Makefile"),(0,r.kt)("p",null,"Here we just Define all our files by hand (here chunk.c main.c and memory.c)"),(0,r.kt)("p",null,"Then we can just call ",(0,r.kt)("inlineCode",{parentName:"p"},"make")," in the terminal and it will only compile output files (.o files) that have been touched freshly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Makefile"},"# whenever main.o or chunk.o (the 2 objectfiles) change we recompile output binary\noutput: main.o chunk.o memory.c\n    gcc main.o chunk.o memory.c -o output\n\n# everytime main.c changes -> compile it to an object file (-c means target outputfile is main.o)\nmain.o: main.c\n    gcc -c main.c\n\n# everytime chunk.c changes -> compile it to an object file (-c means target outputfile is chunk.o)\nchunk.o: chunk.c\n    gcc -c chunk.c\n\nmemory.o: memory.c\n    gcc -c memory.c\n\n# we call these from terminal to remove artifacts\nclean:\n    rm *.o output\n")),(0,r.kt)("h2",{id:"pattern-matching-but-still-a-basic-makefile"},"Pattern matching but still a basic Makefile"),(0,r.kt)("p",null,"Here we would still have to list all files by hand (main.c chunk.c memory.c ...) But pattern match the rule for each corresponding output file"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Makefile"},'## compiler settings:\n# FLAGS=-Wall -Wextra -g -I -03\n\n## list all cfiles (.c) that our project includes\nCCFILES=main.c chunk.c memory.c\n## list all the .o object files that get created (before linking?)\nOBJECTS=main.o chunk.o memory.o\n\n## name of our executable we build to run\nBINARY=bin\n\n\n## build the binary\nall: $(BINARY)\n\n## basically a "rule" that requires all the object files need to be created before we can build the binary\n$(BINARY): $(OBJECTS)\n    gcc -o $@ $^\n\n## (%-signs are wildcards/regex.) To build out all the .o object files\n%.o:%.c\n    gcc -c -o $@ $^\n## with flags the above would be: gcc $(FLAGS) -c -o $@ $^\n\n## manual command to remove all artifacts\nclean:\n    rm -rf $(BINARY) *.o\n')),(0,r.kt)("h2",{id:"a-proper-makefile"},"A Proper Makefile"),(0,r.kt)("p",null,"The above makefiles have a ",(0,r.kt)("strong",{parentName:"p"},"Big Problem"),". When a .h headerfile gets changed and thus the corresponding outputfile needs to be recompiled, Makefile will not see this change, because its in a dependency only.(ex if a constant value in ",(0,r.kt)("inlineCode",{parentName:"p"},"memory.h")," changes ",(0,r.kt)("inlineCode",{parentName:"p"},"memory.o")," will NOT recompile)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Makefile"},"BINARY=bin\nCODEDIRS=. mylib\nINCDIRS=. ./include/ # can be list\n\nCC=gcc\nOPT=-O0\n# generate files that encode make rules for the .h dependencies\nDEPFLAGS=-MP -MD\n# automatically add the -I onto each include directory\nCFLAGS=-Wall -Wextra -g $(foreach D,$(INCDIRS),-I$(D)) $(OPT) $(DEPFLAGS)\n\n# for-style iteration (foreach) and regular expression completions (wildcard)\nCFILES=$(foreach D,$(CODEDIRS),$(wildcard $(D)/*.c))\n# regular expression replacement\nOBJECTS=$(patsubst %.c,%.o,$(CFILES))\nDEPFILES=$(patsubst %.c,%.d,$(CFILES))\n\nall: $(BINARY)\n\n$(BINARY): $(OBJECTS)\n    $(CC) -o $@ $^\n\n# only want the .c file dependency here, thus $< instead of $^.\n#\n%.o:%.c\n    $(CC) $(CFLAGS) -c -o $@ $<\n\nclean:\n    rm -rf $(BINARY) $(OBJECTS) $(DEPFILES)\n\n# shell commands are a set of keystrokes away\ndistribute: clean\n    tar zcvf dist.tgz *\n\n# @ silences the printing of the command\n# $(info ...) prints output\ndiff:\n    $(info The status of the repository, and the volume of per-file changes:)\n    @git status\n    @git diff --stat\n\n# include the dependencies\n-include $(DEPFILES)\n\n# add .PHONY so that the non-targetfile - rules work even if a file with the same name exists.\n.PHONY: all clean distribute diff\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"DEPFLAGS=-MP -MD")," Voodoo-Magic will coupple our gcc and Makefile. To automate .h changes be included in our simple make command"),(0,r.kt)("li",{parentName:"ul"},"The only code that would have to be changed for the most part are the first 3 lines.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BINARY=bin")," defining the binary name we build"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CODEDIRS=. mylib")," defining folders that include our code .c files (current directory and ",(0,r.kt)("inlineCode",{parentName:"li"},"./mylib")," in this case)"),(0,r.kt)("li",{parentName:"ul"},"`` defining folders that include extra .h files etc (in this case again current folder and ./include/)")))))}u.isMDXComponent=!0}}]);