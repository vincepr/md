"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[4432],{3905:(e,a,t)=>{t.d(a,{Zo:()=>c,kt:()=>d});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=n.createContext({}),u=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},c=function(e){var a=u(e.components);return n.createElement(o.Provider,{value:a},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=u(t),m=r,d=g["".concat(o,".").concat(m)]||g[m]||p[m]||l;return t?n.createElement(d,i(i({ref:a},c),{},{components:t})):n.createElement(d,i({ref:a},c))}));function d(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s[g]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<l;u++)i[u]=t[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6364:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>g,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var n=t(7462),r=(t(7294),t(3905));const l={},i="Writing EntityFramework Linq-Queries",s={unversionedId:"csharp/examples/EFLinqQueries",id:"csharp/examples/EFLinqQueries",title:"Writing EntityFramework Linq-Queries",description:"The Data for the following examples",source:"@site/docs/csharp/examples/EFLinqQueries.md",sourceDirName:"csharp/examples",slug:"/csharp/examples/EFLinqQueries",permalink:"/md/csharp/examples/EFLinqQueries",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/csharp/examples/EFLinqQueries.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Delegates in Csharp",permalink:"/md/csharp/examples/Delegate"},next:{title:"EntityFramework - best practices",permalink:"/md/csharp/examples/EntityFramework"}},o={},u=[{value:"The Data for the following examples",id:"the-data-for-the-following-examples",level:2},{value:"Adding Data",id:"adding-data",level:2},{value:"Selecting Data",id:"selecting-data",level:2},{value:"update and deleteing of data",id:"update-and-deleteing-of-data",level:2},{value:"Advanced",id:"advanced",level:2},{value:"Relations between Tables",id:"relations-between-tables",level:2}],c={toc:u};function g(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"writing-entityframework-linq-queries"},"Writing EntityFramework Linq-Queries"),(0,r.kt)("h2",{id:"the-data-for-the-following-examples"},"The Data for the following examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'private class OurDbContext : DbContext\n{\n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {\n        optionsBuilder\n            .UseSqlServer("Data Source=(localdb)\\\\MSSQLLocalDB; Initial Catalog=FootballLeage_EFCore")\n            // Enable explicit loging if executed sql-queries\n            .LogTo(Console.WriteLine, new[] { DbLoggerCategory.Database.Command.Name}, LogLevel.Information)\n            // Disable automatic redacting\n            .EnableSensitiveDataLogging();\n    }\n\n    public DbSet<Teams> Teams { get; set; }\n    public DbSet<League> Leagues { get; set; }\n}\n\npublic class Team {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int LeagueId { get; set; }\n    public virtual League League { get; set; }\n}\n\npublic class League {\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n')),(0,r.kt)("h2",{id:"adding-data"},"Adding Data"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'OurDbContext ctx = new OurDbContext();\n\n// synchronous:\nvar euro = new League { Name = "Europameisterschaft" };\nctx.Leagues.Add(euro);\n// async\nawait ctx.Leagues.AddAsync(new League { Name = "Bundesliega" });\n\n// up to now changes just happened in memory. Persist them:\nctx.SaveChanges();\n\nAddTeamsToLeague();\nawait ctx.SaveChangesAsync(ctx, euro);\n\nstatic async Task AddTeamsToLeague(OurDbContext ctx, League league) {\n    var teams = new List<Team>\n    {\n        new Team {\n            Name = "Redbull Leipzig",\n            // using the "reference by id" to the league\n            LeagueId = league.Id,\n        },\n        new Team {\n            Name = "Fc Bayern",\n            LeagueId = league.Id,\n        },\n        new Team {\n            Name = "VfL Wolfsburg",\n            // using the actual object of the league\n            League = league,\n        }\n    };\n    await ctx.AddRangeAsync(teams);\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"EFCore will translate between using the actual League object vs the LeagueId and resolve those to the same sql-queries under the hood.")),(0,r.kt)("p",null,"In the following example we only explicitly add the team. The new league gets added implicit."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the sql-querys executed will be league first then the team (as neccesary for sql-server)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var legue = new Legue {Name = "English Soccer"};\nvar team = new Team {Name = "Manchester", League = legue};\nawait ctx.Leagues.AddSync(legue);\nawait ctx.SaveChangesAsync();\n')),(0,r.kt)("h2",{id:"selecting-data"},"Selecting Data"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"retrieving data")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// BAD - here we have have a refernce to the DbSet, no sql-querry has ran so far\nvar badAllLeagues = ctx.Legues;\n// here the sql-querry will run.\nforeach (var l in leagues) {\n    Console.WriteLine($"{league.Name}");    // the "bad" thing here is that:\n    // the db-connection will stay open for the whole duration of the loop\n}\n\n// GOOD - in the next line on the other hand we directly run the "select * from leagues"\nvar allLeagues = ctx.Legues.ToList();\nforeach (var l in leagues) {                // at this line the db-connection is already closed\n    Console.WriteLine($"{league.Name}");    // and everything happens in memory. \n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"filtering data")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var leagues = await ctx.Leagues.Where(l => l.Name =="Bundesliega").ToListAsync();\nvar teams = await ctx.Teams.Where(t => t.Name.Contains("Bayern")).ToListAsync();\n// we can use SQL-Native: sql-"LIKE" or sql-"Contains" with the EF.Functions.\nvar teams2 = await ctx.Teams.Where(t => EF.Functions.Like(t.Name, "%Wolfs%"));\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// firstOrDefault is expecting a list and will pick the first:\nvar first     = await ctx.Leagues\n    .Where(l => l.Name.Contains("A"))\n    .FirstOrDefaultAsync();\nvar alsofirst = await ctx.Leagues\n    .FirstOrDefaultAsync(l => l.Name.Contains("A"));\n\n// single is expacting EXACTLY one and will throw/null if multiple matches are found\nvar single   = await ctx.Leagues\n    .Where(l => l.Name.Contains("c"))\n    .SingleAsync();\nvar wontThrow = await ctx.Leagues\n    .Where(l => l.Name.Contains("c"))\n    .SingleOrDefaultAsync();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"aggregate functions:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var leagues = ctx.Leagues;\nvar count = await leagues.CountAsync();         // SELECT COUNT(*)      -> int\nvar longCount = await leagues.LongCountAsync(); // SELECT COUNT_BIG(*)  -> int64\nvar min = await leagues.MinAsync();\nvar max = await leagues.MaxAsync();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"find by primary key (benefit of beeing fast)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var f = await leagues.FindAsync(2); // where Id==2;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"alternative syntax:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var teams = from i in ctx.Teams select i;   // select * from teams\nvar same = await (from i in ctx.Teams select i).ToListAsync();\n\nvar teams2 =    from i in ctx.Teams\n                where i.Name="Fc Bayern"\n                select i.Id;\n\n')),(0,r.kt)("h2",{id:"update-and-deleteing-of-data"},"update and deleteing of data"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"update")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var team = ctx.Teams.Find(2);\nleague.Name = "Newname";\nctx.SaveChanges();\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"delete",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"by default Ef will generate relationships with on delete cascade.")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var listOfTeams = ctx.Teams.Where(t => t.Name=="Newname");\nctx.Teams.RemoveRange(listOfTeams);\n\nvar team = ctx.Teams.Find(2);\nctx.Team.Remove(team);\n')),(0,r.kt)("h2",{id:"advanced"},"Advanced"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"AsNoTracking - in a scenario where we need reaonly data this releases data quicker,\nsince EFCore does't have to keep track if the object gets changed etc.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var withTrackingIsTheDefault = ctx.Teams.FirstOrDefault(q => q.Id == 2);\nvar withNoTracking = ctx.Teams.AsNoTracking().FirstOrDefault(q => q.Id == 2);\n\nwithTrackingIsTheDefault.Name = "this will get written in the db";\nwithNoTracking = "this change never touches our db";\n\nvar entriesBefore = ctx.ChangeTracker.Entries();    // breakpoint here\nctx.SaveChanges();\nvar entriesAfter = ctx.ChangeTracker.Entries();     // breakpoint here\n')),(0,r.kt)("h2",{id:"relations-between-tables"},"Relations between Tables"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Team {\n    //...\n    // here the foreign key is not nullable -> so will default on delte cascade when that table is removed etc.\n    public int LeagueId { get; set; }\n\n    // here on the other hand the Team can exists without a corresponding League. (on delete restrict would be generated etc...)\n    public int? LeagueId { get; set; }\n\n    // this by it's own would also generate a nullable foreign reference\n    public virtual League League { get; set; }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"instead of having to write a manual query for all Teams of one league (would have to use a join) EF provides:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class League {\n    // easy way to access corresponding teams for each League.\n    public List<Team> Teams { get; set; }   // ICollection IEnumerable would also work the same\n}\n")))}g.isMDXComponent=!0}}]);