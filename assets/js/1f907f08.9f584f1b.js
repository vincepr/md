"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[8048],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return t?r.createElement(h,l(l({ref:n},u),{},{components:t})):r.createElement(h,l({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3708:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(7462),a=(t(7294),t(3905));const i={},l="Concurrency in Rust",o={unversionedId:"rust/12Concurrency",id:"rust/12Concurrency",title:"Concurrency in Rust",description:"Threads",source:"@site/docs/rust/12Concurrency.md",sourceDirName:"rust",slug:"/rust/12Concurrency",permalink:"/md/rust/12Concurrency",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/12Concurrency.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"OOP in Rust - Object-Oriented paradigms in Rust",permalink:"/md/rust/11OOP"},next:{title:"Macros in Rust",permalink:"/md/rust/13macros"}},s={},c=[{value:"Threads",id:"threads",level:2},{value:"Waiting for threads to finish",id:"waiting-for-threads-to-finish",level:3},{value:"move keyword to transferr ownerhip into Threads(/closures)",id:"move-keyword-to-transferr-ownerhip-into-threadsclosures",level:3},{value:"Message Passing",id:"message-passing",level:2},{value:"multiple producers for a channel",id:"multiple-producers-for-a-channel",level:3},{value:"Shared State Concurrency",id:"shared-state-concurrency",level:2},{value:"Mutex in Rust with Atomic Reference Counting",id:"mutex-in-rust-with-atomic-reference-counting",level:3},{value:"Sync and Send Traits",id:"sync-and-send-traits",level:2},{value:"Send",id:"send",level:3},{value:"Sync",id:"sync",level:3}],u={toc:c};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"concurrency-in-rust"},"Concurrency in Rust"),(0,a.kt)("h2",{id:"threads"},"Threads"),(0,a.kt)("p",null,"Rust attempts to mitigate the negative effects of using threads, but special care is still required to avoid, race conditions, dedlocks etc..."),(0,a.kt)("p",null,"The rust standard library uses a 1:1 model of thread implementation of system-threads to language-threads."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!("first thread: {}", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!("from mian: {}", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n')),(0,a.kt)("h3",{id:"waiting-for-threads-to-finish"},"Waiting for threads to finish"),(0,a.kt)("p",null,"using the `",(0,a.kt)("inlineCode",{parentName:"p"},"join")," Handles, we can sync up again after the thread has fully completed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"/// we add a thread variable to identify our thread:\n    let handle = thread::spawn(|| {\n/// ...\n/// at the end of the above main we can add:\n    handle.join().unwrap();\n")),(0,a.kt)("h3",{id:"move-keyword-to-transferr-ownerhip-into-threadsclosures"},"move keyword to transferr ownerhip into Threads(/closures)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    let handle = thread::spawn(move || {              // we have to move v into the closure if we want to access it inside\n        println!(\"Here is vector from inside a thread: {:?}\", v)\n    });\n    handle.join().unwrap();\n    //drop(v);               // rust's borrowing rules will not allow this (since we moved v's ownership inside the closure)\n}\n")),(0,a.kt)("h2",{id:"message-passing"},"Message Passing"),(0,a.kt)("p",null,"A popular approach to ensure safe concurrency is ",(0,a.kt)("strong",{parentName:"p"},"message passing"),". (like go routines with channels)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"in rust std-library we have (among others) ",(0,a.kt)("inlineCode",{parentName:"li"},"mpsc")," ",(0,a.kt)("em",{parentName:"li"},"multiple producer"),", ",(0,a.kt)("em",{parentName:"li"},"single consumer"),". "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tx")," is the ",(0,a.kt)("em",{parentName:"li"},"transmitter"),", the second element ",(0,a.kt)("inlineCode",{parentName:"li"},"rx")," is the ",(0,a.kt)("em",{parentName:"li"},"receiver"),";")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    // open a thread that sends some data down the channel:\n    thread::spawn(move || {\n        let val = \'String::from("hello from thread");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!("Got in main: {}", received);\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the receiver ",(0,a.kt)("inlineCode",{parentName:"li"},"rx")," has two useful methods: ",(0,a.kt)("inlineCode",{parentName:"li"},"recv()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"try_recv()"),". ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recv()")," will block till a value is stent. It will return in a ",(0,a.kt)("inlineCode",{parentName:"li"},"Result<T,E>"),". Once the transmitter closes recv will return an error to signal, that no more values will be coming."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"try_recv()")," does not block but instead return a ",(0,a.kt)("inlineCode",{parentName:"li"},"Result<T,E>")," immediately. An Ok with a value or an Error if there arent any messages at this time.")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || { from the thread\n        let vals = vec![\n            String::from("hello"),\n            String::from("from the"),\n            String::from("thread"),\n        ];\n        for val in vals{\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n        // println!("sending value: {}", vals)       //not allowed since we \'moved\' our vals back out\n    });\n\n    for received in rx{\n        println!("Got in main: {}", received);\n    }\n}\n')),(0,a.kt)("h3",{id:"multiple-producers-for-a-channel"},"multiple producers for a channel"),(0,a.kt)("p",null,"We can create multiple producers (with a mscp) by cloning the producer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let (tx, rx) = mpsc::channel();\n\n// first thread:\nlet tx1 = tx.clone();\nthread::spawn(move || {\n    let vals = vec![1,2,3,4,5];\n    for val in vals{\n        tx1.send(val).unwrap();\n        thread::sleep(Duration::from_secs(2));\n    }\n});\n// second thread:\nthread::spawn(move || {\n    let vals = vec![99,88,77,66,55,44,33,22,11,0];\n    for val in vals{\n        tx.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n// receive in main channel:\nfro received in rx {\n    println!("Got: {}", received);\n}\n')),(0,a.kt)("h2",{id:"shared-state-concurrency"},"Shared State Concurrency"),(0,a.kt)("p",null,"Another way of handeling concurrency: read-,write- locked mutexes..., atomic values."),(0,a.kt)("h3",{id:"mutex-in-rust-with-atomic-reference-counting"},"Mutex in Rust with Atomic Reference Counting"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We cant just wrap our Mutex in a Reference Counted Pointer, copy that and move it into the threads. ",(0,a.kt)("inlineCode",{parentName:"li"},"Rc")," is ",(0,a.kt)("strong",{parentName:"li"},"NOT")," threadsave (because it does not implement the send trait)"),(0,a.kt)("li",{parentName:"ul"},"Instead we can use ",(0,a.kt)("inlineCode",{parentName:"li"},"Arc<T>"),". A atmoic reference counted type.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::{Mutex, Arc};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));  // Reference Counted Pointer to our Mutex\n    let mut handles = vec![];\n    for _ in 0..10{\n        let counter = Arc::clone(&counter);\n        let handle= thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num +=1;\n        });\n        handles.push(handle);\n    }\n    // wait for threads to finish:\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!("m: {m}"); // -> 10\n}\n')),(0,a.kt)("p",null,"Atomic types in general Implement a lot of Primitives that are threadsave."),(0,a.kt)("h2",{id:"sync-and-send-traits"},"Sync and Send Traits"),(0,a.kt)("p",null,"We could implement own concurrency features for custom Types etc. Send Trait and Sync Trait are part of `",(0,a.kt)("inlineCode",{parentName:"p"},"std::marker")),(0,a.kt)("h3",{id:"send"},"Send"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Send")," marker trait indicates that ownership of values can be transferred between threads."),(0,a.kt)("p",null,"Most Rust types are Send by default, except Pointers. For example Reference Counted Pointer: ",(0,a.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is not. Because if we cloned it and both threads tried to write to it at the same time we would create a racecondition."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Any type composed entirely of Send types is automatically marked Send aswell.")),(0,a.kt)("h3",{id:"sync"},"Sync"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Sync")," marker trait indicates that is safe to be referenced from multiple threads."),(0,a.kt)("p",null,"Meaning the type reference can be sent safely to another thread."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Any type composed entirely of Sync types is automatically marked Sync aswell.")),(0,a.kt)("h3",{id:""}))}d.isMDXComponent=!0}}]);