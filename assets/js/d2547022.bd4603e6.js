"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[9871],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,k=m["".concat(s,".").concat(d)]||m[d]||c[d]||l;return n?a.createElement(k,i(i({ref:t},p),{},{components:n})):a.createElement(k,i({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9717:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={},i="Some Notes while starting to learn Rust",o={unversionedId:"rust/02start",id:"rust/02start",title:"Some Notes while starting to learn Rust",description:"Setup",source:"@site/docs/rust/02start.md",sourceDirName:"rust",slug:"/rust/02start",permalink:"/md/rust/02start",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/02start.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gotchas",permalink:"/md/go/04gotchas"},next:{title:"Ownership Principles in Rust",permalink:"/md/rust/03owernership"}},s={},u=[{value:"Setup",id:"setup",level:2},{value:"Automatic Formatting with rustfmt",id:"automatic-formatting-with-rustfmt",level:3},{value:"Cargo",id:"cargo",level:3},{value:"Basics",id:"basics",level:2},{value:"Documentation",id:"documentation",level:3},{value:"Print out",id:"print-out",level:3},{value:"Importing",id:"importing",level:3},{value:"Exporting",id:"exporting",level:3},{value:"Common Programming Concepts",id:"common-programming-concepts",level:2},{value:"Variables and Mutability",id:"variables-and-mutability",level:3},{value:"Number literals:",id:"number-literals",level:3},{value:"Integer Overflow",id:"integer-overflow",level:3},{value:"Compond Types",id:"compond-types",level:3},{value:"Touple",id:"touple",level:4},{value:"Array",id:"array",level:4},{value:"Vector",id:"vector",level:4},{value:"Statements vs Expressions",id:"statements-vs-expressions",level:3},{value:"using if in a let Statement",id:"using-if-in-a-let-statement",level:3},{value:"Different Loops",id:"different-loops",level:2},{value:"loop",id:"loop",level:3},{value:"while loop",id:"while-loop",level:3},{value:"for loop",id:"for-loop",level:3}],p={toc:u};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"some-notes-while-starting-to-learn-rust"},"Some Notes while starting to learn Rust"),(0,r.kt)("h2",{id:"setup"},"Setup"),(0,r.kt)("h3",{id:"automatic-formatting-with-rustfmt"},"Automatic Formatting with rustfmt"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo fmt")," to format the whole project according to community code style guidelines."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo fix")," to fix some compiler warnings automatically, if they have a clear way (stay away from while learning)"),(0,r.kt)("li",{parentName:"ul"},"optional linter: ",(0,r.kt)("inlineCode",{parentName:"li"},"rustup component add clippy")," ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo clippy"))),(0,r.kt)("h3",{id:"cargo"},"Cargo"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"create a new project: ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo new hello_project")),(0,r.kt)("li",{parentName:"ul"},"create a new project inside existing folder: ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo new")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo build")," builds a binary to ",(0,r.kt)("inlineCode",{parentName:"li"},"./target/debug/projectname")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo run")," to build and run."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo check")," to check for compiler errors (nice if building takes longer)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo build --release")," to compile it with optimizations")),(0,r.kt)("h2",{id:"basics"},"Basics"),(0,r.kt)("h3",{id:"documentation"},"Documentation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// comment\n/* block comment */\n\n/// Generate library docs for the following item. support MARKDOWN!\n//! Generate library docs for the enclosing item.\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo doc --open"),"    to compile all included md-documentation to a searchable html."),(0,r.kt)("li",{parentName:"ul"},"The style of doc comment //! adds documentation to the item that contains the comments rather than to the items following the comments. We typically use these doc comments inside the crate root file (src/lib.rs by convention) or inside a module to document the crate or the module as a whole:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"src/lib.rs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n")),(0,r.kt)("h3",{id:"print-out"},"Print out"),(0,r.kt)("p",null,"handled by a series of macros defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"std::fmt")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"format!")," formatted text to String"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"print!")," ",(0,r.kt)("inlineCode",{parentName:"li"},"println!")," pinted to console (io::stdout)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"eprint!")," ",(0,r.kt)("inlineCode",{parentName:"li"},"eprintln!")," printed to the standard error (io::stderr)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// in general the {} will be automatically replaced with the stringified args.\nprintln!("{subject} {verb} {object}",\n    object="He",\n    subject=10,\n    verb="aged by");\nprintln("{0}, this is {1}. {0} how are you?", "Alice", "Bob");\n\n// Different formatting can be invoked by specifying the format character :\nprintln!("Base 10:               {}",   69420); // 69420\nprintln!("Base 2 (binary):       {:b}", 69420); // 10000111100101100\nprintln!("Base 8 (octal):        {:o}", 69420); // 207454\nprintln!("Base 16 (hexadecimal): {:x}", 69420); // 10f2c\nprintln!("Base 16 (hexadecimal): {:X}", 69420); // 10F2C\n\n// Min length right-justify text: (adding whitespaces to the left:)\nprintln!("{number:>5}", number=1);              // ->     1\n// pad numbers with extra zeros\nprintln("{number:0<5}", number=1);              // -> 10000\n// named arguments in the format specifier by appending a $\nprintln("{numb:0>width$}", numb=1, width=5);    // -> 00001\n// capture variales:\nlet number: f64 = 1.0;\nlet width: usize = 5;\nprintln!("{number:>width$}");                   // ->     1\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fmt::Debug: Uses the {:?} marker. Format text for debugging purposes."),(0,r.kt)("li",{parentName:"ul"},'that way we can "print" structs etc, that do not implement ',(0,r.kt)("inlineCode",{parentName:"li"},"std::fmt::Display"),", the default toString (interface?)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'println!("{1:?} {0:?} is the {actor:?} name.",\n             "Slater",\n             "Christian",\n             actor="actor\'s");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pretty printing by using ",(0,r.kt)("inlineCode",{parentName:"li"},"{:#?}")," extends the ",(0,r.kt)("inlineCode",{parentName:"li"},"fmt::Debug"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug)]\nstruct Person<\'a> {\n    name: &\'a str,\n    age: u8\n}\n\nfn main() {\n    let name = "Peter";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Pretty print\n    println!("{:#?}", peter);\n}\n')),(0,r.kt)("h3",{id:"importing"},"Importing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use std::io;\n\nio::stdin()\n\n// would be the same as:\nstd::io::stdin()\n")),(0,r.kt)("h3",{id:"exporting"},"Exporting"),(0,r.kt)("p",null,"This is useful if we were to build a library. Instead of long paths import paths that make sense logically for our programm like ",(0,r.kt)("inlineCode",{parentName:"p"},"mylib::api::util::types::some_struct")," we can re-export to make it easy accessable: ",(0,r.kt)("inlineCode",{parentName:"p"},"mylib::some_struct")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"in the example the points of interest could be PrimaryColor, SecondaryColor and the mix function. So we move them to the public API."),(0,r.kt)("li",{parentName:"ul"},"this will also move the autogenerated documentation for the public API elements (from ",(0,r.kt)("inlineCode",{parentName:"li"},"/// # h1")," markdown) to the frontpage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//! # Art\n//!\n//! A library for modeling artistic concepts.\n\n// So we re-export them to the public API:\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n// \n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n        // --snip--\n    }\n}\n")),(0,r.kt)("h2",{id:"common-programming-concepts"},"Common Programming Concepts"),(0,r.kt)("h3",{id:"variables-and-mutability"},"Variables and Mutability"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let mut")," to indicate the value can be reassigned. (so even changed from a int -> string)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"const")," must be without mut. Also types (ex. Uint/String) have to be assigned.")),(0,r.kt)("h3",{id:"number-literals"},"Number literals:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"you can use ",(0,r.kt)("inlineCode",{parentName:"li"},"_")," as a visual separator to make numbers more human readable.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Decimal         98_222\nHex             0xff\nOctal           0o77\nBinary          0b1111_0000\nByte (u8 only)  b'A'\n")),(0,r.kt)("h3",{id:"integer-overflow"},"Integer Overflow"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when in debug mode, rust checks for overflows that will panic"),(0,r.kt)("li",{parentName:"ul"},"when building with ",(0,r.kt)("inlineCode",{parentName:"li"},"--releaste")," there is no overflow checking. Just the as expected Overflowing.")),(0,r.kt)("h3",{id:"compond-types"},"Compond Types"),(0,r.kt)("h4",{id:"touple"},"Touple"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fixed length once declared. Can hold multiple different types.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let tup1: (i32, f64, u8) = (500, 6.4, 1);\nlet tup2 = (500, 6.4, 1);\nlet (x,y,z) = tup2;          // destructuring is possible to get individual values\nlet mid = tup1.0;            // refferencing by index is possible aswell\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the touble without any values has a special name: ",(0,r.kt)("strong",{parentName:"li"},"unit"),". This value and its type are written ",(0,r.kt)("inlineCode",{parentName:"li"},"()")," and represent an empty value or empty return type. Expressions implicitly return this (if nothing else is returned).")),(0,r.kt)("h4",{id:"array"},"Array"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fixed length and can hold only one type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let a = [1,2,3];\nlet b: [i32; 5] = [1,2,1,2,3];\nlet same: [3;6];    // all 5 entries are the same value(3) -> [3,3,3,3,3,3]\n")),(0,r.kt)("h4",{id:"vector"},"Vector"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"unlike the array a vector is not fixed in size.")),(0,r.kt)("h3",{id:"statements-vs-expressions"},"Statements vs Expressions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Statements are everything without a return value."),(0,r.kt)("li",{parentName:"ul"},"Expressions evaluate to a value. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Examples: calling a fn, calling a macro, a new scope block created with Curly-Braces."),(0,r.kt)("li",{parentName:"ul"},"Expressions do ",(0,r.kt)("strong",{parentName:"li"},"not include ending semicolons"),". ")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// expression example\nlet y = {\n    let x = 3;\n    x + 10\n};\nprintln!("The value of y is: {y}"); //-> The value of y is: 13\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"blocks of code always evaluate to the last expression in them."),(0,r.kt)("li",{parentName:"ul"},"we can use expressions as implicit return in functions:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n")),(0,r.kt)("h3",{id:"using-if-in-a-let-statement"},"using if in a let Statement"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let condition = true;\nlet number = if condition {5} else {6};\n")),(0,r.kt)("h2",{id:"different-loops"},"Different Loops"),(0,r.kt)("h3",{id:"loop"},"loop"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we can use breaks optional value to pass a value out of the scope of the loop itself:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut counter =0;\nlet result = loop{\n    counter += 1;\n    println!("going again");\n    if counter == 5{\n        break counter * 10;\n    }\n}\nprintln("result is {result}");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we can label loops to distinguish break and continue for inner and outer loops.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut count = 0;\n\'counting_up: loop{\n    let mut remaining = 10;\n    loop {\n        println!("remaining = {remaining}");\n        if remaing == 9 {\n            break;\n        }\n        if count == 2{\n            break \'counting_up;\n        }\n        remaining -= 1;\n    }\n    count += 1;\n}\nprintln!("End count = {count}")\n')),(0,r.kt)("h3",{id:"while-loop"},"while loop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"while number != 0 {\n    number -= 1;\n}\n")),(0,r.kt)("h3",{id:"for-loop"},"for loop"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let a = [10,20,30,40,50];\nfor element in a {\n    println!("the value is: {element}")\n}\n\n// using for loop with a Range (1..4). .rev() to reverse said Range:\nfor nr in (1..4).rev() {\n    println!("{nr}")\n}\n// 3\n// 2 \n// 1\n')))}m.isMDXComponent=!0}}]);