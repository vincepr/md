"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[3734],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(o,".").concat(d)]||m[d]||c[d]||l;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[m]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8839:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={},i="Structures related to data in Rust",s={unversionedId:"rust/04data",id:"rust/04data",title:"Structures related to data in Rust",description:"structs",source:"@site/docs/rust/04data.md",sourceDirName:"rust",slug:"/rust/04data",permalink:"/md/rust/04data",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/04data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Ownership Principles in Rust",permalink:"/md/rust/03owernership"},next:{title:"Crates projects, packages and modules in Rust",permalink:"/md/rust/05crates"}},o={},u=[{value:"structs",id:"structs",level:2},{value:"Touple struct",id:"touple-struct",level:3},{value:"structs without any fields",id:"structs-without-any-fields",level:3},{value:"Enums",id:"enums",level:2},{value:"Option Enum",id:"option-enum",level:3},{value:"Match expression",id:"match-expression",level:3},{value:"if let statement",id:"if-let-statement",level:3},{value:"std collections",id:"std-collections",level:2},{value:"Vector",id:"vector",level:3},{value:"iterating over a vector",id:"iterating-over-a-vector",level:4},{value:"enum to store multiple types in a vector",id:"enum-to-store-multiple-types-in-a-vector",level:4},{value:"String",id:"string",level:3},{value:"Concatenation",id:"concatenation",level:4},{value:"indexing and slicing strings",id:"indexing-and-slicing-strings",level:4},{value:"iterating over strings",id:"iterating-over-strings",level:4},{value:"Hash Maps",id:"hash-maps",level:3},{value:"Different strategies to insert over existing keys",id:"different-strategies-to-insert-over-existing-keys",level:4}],p={toc:u};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"structures-related-to-data-in-rust"},"Structures related to data in Rust"),(0,r.kt)("h2",{id:"structs"},"structs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if a struct instance is mutable, the whole thing is mutable. (cant specify certain fields only)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\nfn main() {\n    let mut user1 = User{\n        active: true,\n        username: String::from("Bob"),\n        email: String::from("bob@ross.wrong"),\n        sign_in_count: 0,\n    };\n    user1.email = String::from("bob@ross.gg");\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"writing a constructor there is a shorthand syntax. (using same arg- and field-name)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn build_user(email: String, username: String)-> User{\n    User{\n        active: true,\n        username,               // instead of username: username\n        email,\n        sign_in_count: 0,\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"short way to move (NOT COPY) a user and change some fields:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let user2 = User{\n    email: String::from("anotherBob@ross.us"),\n    ..user1                     // must be last\n};\n// user1 not usable anymore (UNLESS we would set email and username)\n')),(0,r.kt)("p",null,"as discussed in the Ownership chapter, we just moved the data and now user1 exists no longer. Thats because User struct includes 2 strings. If we had set both email and username, the other values would be copied over and user1 would still exist as a variable!"),(0,r.kt)("h3",{id:"touple-struct"},"Touple struct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n")),(0,r.kt)("h3",{id:"structs-without-any-fields"},"structs without any fields"),(0,r.kt)("p",null,"unit-like structs without any fields hold no data. still useful since we can use traits on them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct AlwaysEqual;\nfn main(){\n    let subject = AlwaysEqual;\n}\n")),(0,r.kt)("h2",{id:"enums"},"Enums"),(0,r.kt)("p",null,"You can put any kind of data inside an enum variant: strings, numeric types or structs, even other enums..."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'enum IpAddrKind {\n    V4,\n    V6,\n}\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nlet test = IpAddrKind::V4;\nlet home = IpAddr {\n    kind: IpAddrKind::V4,\n    address: String::from("127.0.0.1"),\n};\n\nfn route(ip_kind: IpAddrKind) {}    // takes in any variant\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it is also possible to put data directly into each enum variant (so there is no need for an extra struct in this case):"),(0,r.kt)("li",{parentName:"ul"},"they can even have different data inside:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from("::1"));\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"there is a std implementation for ip in rust aswell:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n\nlet localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\nlet localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n\nassert_eq!("127.0.0.1".parse(), Ok(localhost_v4));\nassert_eq!("::1".parse(), Ok(localhost_v6));\n\nassert_eq!(localhost_v4.is_ipv6(), false);\nassert_eq!(localhost_v4.is_ipv4(), true);\n')),(0,r.kt)("h3",{id:"option-enum"},"Option Enum"),(0,r.kt)("p",null,"Rust does ",(0,r.kt)("strong",{parentName:"p"},"NOT")," have null. Instead there are Options, a bit like Js-Promises."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Definition in the std lib. It is automatically included, without explicit importing it. (along with ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Some(T)"),")")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum Option<T> {    //implemented using generic type <T>\n    None,\n    Some(T),\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"examples:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let some_number = Some(5);\nlet some_char = Some('x');\nlet absent_number = Option<i32> = None;\nlet x :i32 = 4\n// let sum = some_number + x //is not allowed before \"checking for null / if the option is None\"\n")),(0,r.kt)("h3",{id:"match-expression"},"Match expression"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"matches only compile if they cover all possibilites.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'enum UsState {\n    Alabama,\n    Alaska,\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(c: Coin) -> u8 {\n    match c {\n        Coin::Penny => {\n            println!("Lucky penny found");\n            1\n        }\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) =>{\n            println!("State of the quarter found: {:?}", state);\n            25\n        }\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Matching a Option")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// if the Option is not "null" we add 1 to it then return it. If "null" we return "null"\nfn plus_one(x: Option<i32>) -> Option<i32>{\n    match x{\n        None => None,\n        Some(i) => Some(i+1)\n    }\n\n    let five = some(5);\n    let six = plus_one(five);\n\n    let none = plus_one(None);\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"catch all patterns")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let dice_roll = 5;\nmatch dice_roll {\n    6 => double_points(),\n    other => move_player(other),\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_")," placeholder if we do not need to use these numbers/states")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let dice_roll = 5;\nmatch dice_roll {\n    1 => loose(),\n    6 => double_points(),\n    _other_ => reroll(),\n}\n\n// we can even do nothing:\nmatch dice_roll2 {\n    1 => loose(),\n    6 => points(),\n    _ => (),\n}\n")),(0,r.kt)("h3",{id:"if-let-statement"},"if let statement"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"another way to extract Option types out:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let config_max = Some(3u8);\nif let Some(max) = config_max {\n    println!("The maximum is configured to be {}", max);\n}\n\n// another example\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!("State quarter from {:?}!", state);\n} else {\n    count += 1;\n}\n')),(0,r.kt)("h2",{id:"std-collections"},"std collections"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::collections")," ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/collections/index.html"},"https://doc.rust-lang.org/std/collections/index.html")," offers good implementions of default data structures."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"like vector, string, hash map, binary tree...")),(0,r.kt)("h3",{id:"vector"},"Vector"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"stored on the heap")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let v1: Vec<i32> = Vec::new();      // without initial value\nlet v2 = vec![1,2,3,4,5]            // with initial values, with the vec! macro.\n\n// adding to a vector:\nlet mut v3 = Vec::new();\nv3.push(5);\nv3.push(6);\n\n//reading elements:\nlet third: Option<&i32> = v2.get(2);\nmatch third {\n    Some(third) => println!("the 3rd element is {third}"),\n    None => println!("There is no 3rd element"),\n}\n\nlet thiswillcrash = &v2[100];       // will panic\nlet thiswill_none = v2.get(100);    // will return None\n')),(0,r.kt)("p",null,"Vectors are allocated next to each other in memory. Because of this, the following will not compile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    let mut v = vec![1,2,3,4,5,6];\n    let first = &v[0];\n    v.push(7);\n    println!("{:?}", v);        // -> [1, 2, 3, 4, 5, 6, 7]\n    // println!("{:?}", first); // this wont compile!\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"since after ",(0,r.kt)("inlineCode",{parentName:"li"},"v.push(7)")," v will be reallocated to some bigger space. Now first might point to some wrong spot. The compiler catches this.")),(0,r.kt)("h4",{id:"iterating-over-a-vector"},"iterating over a vector"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![11,22,33];\nfor i in &v {\n    println!("{i}");\n}\n\nlet mut v2 = vec![11,22,33];\nfor i in &v {\n    *i += 100;                  // dereferencing with * to get the value behind the pointer (like in go)\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"similar to above we are not allowed to add to &v while in the loop for example. While changing the referenced values is allowed.")),(0,r.kt)("h4",{id:"enum-to-store-multiple-types-in-a-vector"},"enum to store multiple types in a vector"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"vectors can only store the same type. But with a enum we can basically circumvent this:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'enum Cell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nlet row = vec![\n    Cell::Text(String::from("numbers of people")),\n    Cell::Int(30),\n    Cell::Text(String::from("numbers of households")),\n    Float::(20.5),\n];\n')),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"&str")," string slices are references to some utf8 encoded string data. (and is stored on Stack)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"String")," type on the other hand is provided by the std-library and is a growable mutable owned utf encoded string type. Stored on the Heap."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"actually string is implemented as a wrapper arround the previous vector type (of bytes).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// create a empty string:\nlet mut s = String::new();\n\n// create from data/stringliterals\nlet data_from_some_file = "blah blah blah";\nlet s1 = data.to_string();                      // available on any type that implements the Display type\nlet s2 = "also works on string literals directly".to_string();\n\n// initial value\nlet s3 = String::from("some initial value");\n\n// add to strings\ns.push_str("foobar");\n\ns.push(\'A\')             // single characters\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"push_str()")," only takes in a stringslice and does ",(0,r.kt)("strong",{parentName:"li"},"not")," take ownership, so the following is allowed:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s1 = String::from("foo");\nlet s2 = "bar";\ns1.push_str(s2);\nprintln!("s1 is {s1}");     // -> s1 is foobar\nprintln!("s2 is {s2}");     // -> s2 is bar\n')),(0,r.kt)("h4",{id:"concatenation"},"Concatenation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s1 = String::from("Hello ");\nlet s2 = String::from("world");\nlet s3 = s1 + &s2;              // short-form for: let s3 = s1.add(&s2);     \n\n// note s1 has been moved and can no longer be used. (s2 and s3 are fine)\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"format!")," macro to make concatenating multiple strings even more streamlined:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s1 = String::from("hello");\nlet s2 = String::from("world");\nlet s3 = String::from("whatsup");\n\nlet s = format!("{s1} {s2}, {s3}?");\n')),(0,r.kt)("h4",{id:"indexing-and-slicing-strings"},"indexing and slicing strings"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"and again: Strings do ",(0,r.kt)("strong",{parentName:"li"},"NOT")," allow indexing: ",(0,r.kt)("inlineCode",{parentName:"li"},' String::from("hello")[0];')," . But Stringslices do: ",(0,r.kt)("inlineCode",{parentName:"li"},'let h = "hello"; let a = &h[0] ')),(0,r.kt)("li",{parentName:"ul"},"in slicing we also need to take care not to slice inbetween a utf8 encoded character!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let hello = "\u0417\u0434\u0440\u0430\u0432";\nlet s = &hello[0..4];\n// let s2 = &hello[0..1];       // will crash because it tries to slice the first char in half!\n')),(0,r.kt)("h4",{id:"iterating-over-strings"},"iterating over strings"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we need to define if we want to iterate over the raw bytes or the utf8 encoded Characters:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// iterate over chars\nfor ch in "a2b3\u0434\u04325".chars(){\n    println!("{ch}")\n}\n\n// iterate over bytes\nfor by in "a2b3\u0434\u04325".bytes(){\n    println!("{by}")\n}\n')),(0,r.kt)("h3",{id:"hash-maps"},"Hash Maps"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"key value pairs (JS Ojects...)"),(0,r.kt)("li",{parentName:"ul"},"stored on the heap. So if we add to it we remove references to elements of it we made before. Borrowing rules etc."),(0,r.kt)("li",{parentName:"ul"},"uses SipHash Algorithm for hashing by default. (provides some DoS protection against attacks abusing hashing). If speed is needed easy to switch the alorith out by getting another hasher type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// need to import it\nuse std::collections::HashMap;\n\n// create it empty and write to it\nlet mut scores = HashMap::new();\nscores.insert(String::from("BlueTeam"), 10);\nscores.insert(String::from("RedTeam"), 50);\n\n// accessing values\nlet team_name = String::from("TeamRed");\nlet s = scores.get(&team_name).copied().unwrap_or(0);\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Here the get method returns an ",(0,r.kt)("inlineCode",{parentName:"li"},"Option<&V>")," or None. "),(0,r.kt)("li",{parentName:"ol"},"We then copy the option to get a ",(0,r.kt)("inlineCode",{parentName:"li"},"Option<i32>")," over a ",(0,r.kt)("inlineCode",{parentName:"li"},"Option<&i32>"),"."),(0,r.kt)("li",{parentName:"ol"},"Afterwards we use ",(0,r.kt)("inlineCode",{parentName:"li"},'unwrap_or("defaultvalue")')," to get a i32 instead of an option.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// iterating over a map:\nfor (key, value) in &scores{\n    println!("{key}:{value}");\n}\n// as usual maps are not ordered and might return differently ordered lists each time.\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If we insert references to values into the hash map, the values won\u2019t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid.")),(0,r.kt)("h4",{id:"different-strategies-to-insert-over-existing-keys"},"Different strategies to insert over existing keys"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\nlet mut map = HashMap::new();\nmap.insert(String::from("One"), 10);\n\n// just Overwrite the value:\nmap.insert(String::from("One"), 20);\n\n// adding a key,val par only if key isnt present:\nmap.entry(String::from("One")).or_insert(50);                 // does nothing since its already One: 20\nmap.entry(String::from("Two")).or_insert(50);                 // enters Two:50 just fine\n\nprintln!("{:?}", map);\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"example counting how often a word is in a sentence (updating an existing value):")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nfn main(){\n    let text = "this is a text, some realy good text this is. text.";\n    let map = count_words(text);\n    println!("{map:?}");\n}\n\nfn count_words(s: &str)-> HashMap<&str, i32>{\n    let mut map: HashMap<&str, i32> = HashMap::new();\n\n    for word in s.split_whitespace(){\n        let count = map.entry(word).or_insert(0);       // we create our entry with 0 or get a pointer to it\n        *count +=1;\n    }\n    return map;\n}\n')),(0,r.kt)("h1",{id:"generic-data-types"},"Generic Data Types"),(0,r.kt)("p",null,"In Rust generic Types are compiled with Monomorphization. Thus there should be no cost at runtime. Basically it generates binary code for each used variant.."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Generics in Functions")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn max_i32(list: &[i32]) -> &i32 {\n    let mut max = &list[0];\n    for el in list {\n        if el > max {\n            max = el;\n        }\n    }\n    max\n}\n\nfn max_generic<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n    let mut max = &list[0];\n    for el in list {\n        if el > max {\n            max = el;\n        }\n    }\n    max\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Generics in Structs or Enums")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// only accepts same type T\nstruct Coordinate<T> {\n    x: T,\n    y: T,\n}\n// same for struct methods:\nimp<T> Coordinate<T> {\n    fn get_x(&self) -> &T {\n        &self.x\n    }\n}\n\n// accepts different types\nstruct Point<T, U> {\n    a: T,\n    b: U,\n}\n// we can also specify different behavior for different T-types's like this:\nimpl Point<f32> {\n    fn dist_from_zero(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\n\nenum Option<T> {\n    Some(T),\n    None\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n")))}m.isMDXComponent=!0}}]);