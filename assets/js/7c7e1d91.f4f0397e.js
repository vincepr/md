"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[3382],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>v});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=i.createContext({}),u=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=u(e.components);return i.createElement(o.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,v=p["".concat(o,".").concat(m)]||p[m]||c[m]||l;return t?i.createElement(v,s(s({ref:n},d),{},{components:t})):i.createElement(v,s({ref:n},d))}));function v(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=m;var a={};for(var o in n)hasOwnProperty.call(n,o)&&(a[o]=n[o]);a.originalType=e,a[p]="string"==typeof e?e:r,s[1]=a;for(var u=2;u<l;u++)s[u]=t[u];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5807:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>u});var i=t(7462),r=(t(7294),t(3905));const l={},s="Linked List (Singly Linked List)",a={unversionedId:"datastructures/linked_list",id:"datastructures/linked_list",title:"Linked List (Singly Linked List)",description:"Implementation in go",source:"@site/docs/datastructures/linked_list.md",sourceDirName:"datastructures",slug:"/datastructures/linked_list",permalink:"/md/datastructures/linked_list",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/datastructures/linked_list.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hash Table - Hash Map",permalink:"/md/datastructures/hashtable"},next:{title:"Priority Queue - (often implemented with a Heap)",permalink:"/md/datastructures/priority_queue"}},o={},u=[{value:"Implementation in go",id:"implementation-in-go",level:2},{value:"Implementation in Csharp",id:"implementation-in-csharp",level:2}],d={toc:u};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"linked-list-singly-linked-list"},"Linked List (Singly Linked List)"),(0,r.kt)("h2",{id:"implementation-in-go"},"Implementation in go"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n    // linked list example:\n    var m = map[int]string{1: "2", 2: "4", 4: "8"}\n\n    fmt.Println("keys:", MapKeys(m))\n\n    _ = MapKeys[int, string](m)\n\n    lst := List[int]{}\n    lst.Push(10)\n    lst.Push(13)\n    lst.Push(23)\n    fmt.Println("list:", lst.GetAll())\n}\n\nfunc MapKeys[K comparable, V any](m map[K]V) []K {\n    r := make([]K, 0, len(m))\n    for k := range m {\n        r = append(r, k)\n    }\n    return r\n}\n\ntype List[T any] struct {\n    head, tail *element[T]\n}\n\ntype element[T any] struct {\n    next *element[T]\n    val  T\n}\n\nfunc (lst *List[T]) Push(v T) {\n    if lst.tail == nil {\n        lst.head = &element[T]{val: v}\n        lst.tail = lst.head\n    } else {\n        lst.tail.next = &element[T]{val: v}\n        lst.tail = lst.tail.next\n    }\n}\n\nfunc (lst *List[T]) GetAll() []T {\n    var elems []T\n    for e := lst.head; e != nil; e = e.next {\n        elems = append(elems, e.val)\n    }\n    return elems\n}\n')),(0,r.kt)("h2",{id:"implementation-in-csharp"},"Implementation in Csharp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'\npublic static class Example\n{\n    public static void Run() \n    {\n        Console.WriteLine("--- (Singly)LinkedList Example: ---");\n        var list = new SingleLinkedList<string>();\n\n        Console.WriteLine("we expect .First on empty list to be null: "+ list.First is null);\n\n        foreach (var item in list) Console.WriteLine("list empty -> this never gets reached"); \n        \n        list.AddFirst("1");\n        list.AddFirst("2");\n        list.AddFirst("3");\n        var node = list.First;\n        node = list.GetNext(node!);\n        list.AddAfter(node!, "1.5");\n\n\n        foreach (var item in list) Console.WriteLine("Item is: " + item);\n\n        list.Remove(node);\n\n        Console.WriteLine(list.ToString());     // functionality to just print a list itself \n\n        list.Remove(list.FindNode("1.5"));\n        Console.WriteLine(list.ToString());\n    }\n}\n\n/// Singly linked list implementation.\npublic sealed class SingleLinkedList<T> :IEnumerable<T> where T : IComparable<T>\n{\n    public NodeLinkedList<T>? First {get; private set;}\n    public SingleLinkedList(T[]? values = null) \n    {\n        this.First = null;\n        if (values != null) {\n            foreach (var value in values.Reverse()) {\n                this.AddFirst(value);\n            }\n        }\n    }\n\n    /// Adds entry to the Top of the List\n    public void AddFirst(T value) \n    {\n        var newNode = new NodeLinkedList<T>(value);\n        newNode.Next = this.First;\n        this.First = newNode;\n    }\n\n    public NodeLinkedList<T>? GetNext(NodeLinkedList<T> previous) \n    {\n        if (previous == null) return null;\n        return previous.Next;\n    }\n\n\n    public int Count => this.Aggregate(0, (acc, _)=> acc + 1);\n\n    public void AddAfter(NodeLinkedList<T> node, T valueToAdd) \n    {\n        var newNode = new NodeLinkedList<T>(valueToAdd);\n        newNode.Next = node.Next;\n        node.Next = newNode;\n    }\n\n    public bool Remove(NodeLinkedList<T>? node) \n    {\n        var prev = this.First;\n        while (prev is not null) {\n            if (prev is null || prev.Next is null) return false;       // couldnt find node\n            if (prev.Next == node) {\n                // do steps to remove\n                prev.Next = node.Next;\n                return true;\n            }\n            // step to next node:\n            prev = prev.Next;\n        }\n        return false;\n    }\n\n    public NodeLinkedList<T>? FindNode(T value) \n    {\n        var node = this.First;\n        while (node is not null) {\n            if (node.Value.Equals(value)) return node;\n            node = node.Next;\n        }\n        return null;\n    }\n\n    public override string ToString() =>\n        this.Aggregate("[", (acc, x) => $"{acc} {x} ->")\n            .TrimEnd(\'>\')\n            .TrimEnd(\'-\') + "]";\n\n    /* Enumerator to make foreach-loops, .map loops etc possible */\n\n    public IEnumerator<T> GetEnumerator() => new Enumerator(this);\n\n    IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);\n\n    public sealed class Enumerator : IEnumerator<T>\n    {\n        private SingleLinkedList<T> originalList;\n        private NodeLinkedList<T>? previous;\n        private NodeLinkedList<T>? next;\n\n        public Enumerator(SingleLinkedList<T> list) \n        {\n            this.originalList = list;\n            if (list.First is null) {\n                // called with empty list \n                this.previous = null;\n                this.next = null;\n            } else {\n                this.previous = null;\n                this.next = list.First;\n            }\n        }\n\n        // the way we check for null in MoveNext(), that gets called BEFORE each .Current\n        // these should never error. But cleaner would be a custom Throw if null, just in case\n        public object Current => previous!;\n\n        T IEnumerator<T>.Current => previous!.Value;\n\n        public void Dispose() {}                // nothing to do here really\n\n        public bool MoveNext()\n        {\n            if (next is null && previous is null) return false; // started empty\n            if (next is null) {\n                previous = next;\n                next = null;\n                return false;                   // reached end after this read\n            } else {\n                previous = next;                // we set up next pointers\n                next = previous.Next;\n            }\n            return true;\n        }\n\n        public void Reset()\n        {\n            if (originalList.First is null) {\n                // called with empty list \n                this.previous = null;\n                this.next = null;\n            } else {\n                this.previous = originalList.First;\n                this.next = previous.Next;\n            }\n        }\n    }\n\n    /// A Single entry in our linked list is represented by this\n    public sealed class NodeLinkedList<U> //: IEnumerable<T>\n    {\n        public NodeLinkedList(U value)\n        {\n            this.Value = value;\n        }\n        public U Value { get; }\n        public NodeLinkedList<U>? Next{ get; set; }\n    } \n}\n')))}p.isMDXComponent=!0}}]);