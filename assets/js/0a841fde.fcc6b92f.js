"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[6442],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>b});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=r,b=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return t?a.createElement(b,i(i({ref:n},p),{},{components:t})):a.createElement(b,i({ref:n},p))}));function b(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1282:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},i="part 8 - Message Bus with RabbitMQ",s={unversionedId:"csharp/examples/Microservices/part8-rabbitMQ",id:"csharp/examples/Microservices/part8-rabbitMQ",title:"part 8 - Message Bus with RabbitMQ",description:"Goal is to implement the Message-Bus and add the PlatformService as a Publisher and the CommandService as a Subscriber.",source:"@site/docs/csharp/examples/Microservices/part8-rabbitMQ.md",sourceDirName:"csharp/examples/Microservices",slug:"/csharp/examples/Microservices/part8-rabbitMQ",permalink:"/md/csharp/examples/Microservices/part8-rabbitMQ",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/csharp/examples/Microservices/part8-rabbitMQ.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"part 7 - multi resource api",permalink:"/md/csharp/examples/Microservices/part7-multiResourceApi"},next:{title:"part 9 - gRPC",permalink:"/md/csharp/examples/Microservices/part9-gRPC"}},l={},c=[{value:"notes about RabbitMQ",id:"notes-about-rabbitmq",level:2},{value:"starting up RabbitMQ in Kubernetes",id:"starting-up-rabbitmq-in-kubernetes",level:2},{value:"Code in PlatformService - The Publisher",id:"code-in-platformservice---the-publisher",level:2},{value:"Implementing the Message Bus Client",id:"implementing-the-message-bus-client",level:3},{value:"We Use that Bus to send in our Controller",id:"we-use-that-bus-to-send-in-our-controller",level:3},{value:"Code in CommandsService - The Subscriber",id:"code-in-commandsservice---the-subscriber",level:2},{value:"Setup",id:"setup",level:3},{value:"We Publish the above steps to Kubernetes",id:"we-publish-the-above-steps-to-kubernetes",level:2}],p={toc:c};function u(e){let{components:n,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"part-8---message-bus-with-rabbitmq"},"part 8 - Message Bus with RabbitMQ"),(0,r.kt)("p",null,"Goal is to implement the Message-Bus and add the PlatformService as a Publisher and the CommandService as a Subscriber."),(0,r.kt)("h2",{id:"notes-about-rabbitmq"},"notes about RabbitMQ"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Message Broker: accepts, forwards messages"),(0,r.kt)("li",{parentName:"ul"},"Messages are stored on Queues. (in real production those would be persisted if RabbitMQ crashes etc...)"),(0,r.kt)("li",{parentName:"ul"},"uses AMQP - Advanced Message Queuing Protocl (among others)"),(0,r.kt)("li",{parentName:"ul"},"4 types of exchanges",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"direct exchange - delivers messages to queues based on a routing key. ideal for direct/unicasting messaging"),(0,r.kt)("li",{parentName:"ul"},"fanout exchange (used here) - delivers messages to all queues bound to the exchange. ideal for broadcast messages."),(0,r.kt)("li",{parentName:"ul"},"topic exchance - routes messages to 1 or more queues based on routingkey/patterns. ideal for multicasting messages"),(0,r.kt)("li",{parentName:"ul"},"header exchange")))),(0,r.kt)("h2",{id:"starting-up-rabbitmq-in-kubernetes"},"starting up RabbitMQ in Kubernetes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"K8S/rabbitmq-depl.yaml"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: rabbitmq-depl\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: rabbitmq\n  template:\n    metadata:\n      labels:\n        app: rabbitmq\n    spec:\n      containers:\n        - name: rabbitmq\n          image: rabbitmq:3-management\n          ports:\n            ## first port is just to access the "management" webinterface\n            - containerPort: 15672\n              name: rbmq-mgmt-port\n            ## this is the used port for the Bus itself\n            - containerPort: 5672\n              name: rbmq-msg-port\n---\n# the Bus needs to be accessible from the Services inside Kubernetes, so we create a ClusterIP for it\napiVersion: v1\nkind: Service\nmetadata:\n  name: rabbitmq-clusterip-srv\nspec:\n  type: ClusterIP\n  selector:\n    app: rabbitmq\n  ports:\n    - name: rbmq-mgmt-port\n      protocol: TCP\n      port: 15672\n      targetPort: 15672\n    - name: rbmq-msg-port\n      protocol: TCP\n      port: 5672\n      targetPort: 5672 \n---\n# the Bus also needs to be accessible from outside the Kubernetes (at least for development)\n# so we create a LoadbalancerService for it\napiVersion: v1\nkind: Service\nmetadata:\n  name: rabbitmq-loadbalancer\nspec:\n  type: LoadBalancer\n  selector:\n    app: rabbitmq\n  ports:\n    - name: rbmq-mgmt-port\n      protocol: TCP\n      port: 15672\n      targetPort: 15672\n    - name: rbmq-msg-port\n      protocol: TCP\n      port: 5672\n      targetPort: 5672 \n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"then we deploy our messagebus")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl apply -f K8S/rabbitmq-depl.yaml\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"now we can reach out messagebus webinterface with ",(0,r.kt)("inlineCode",{parentName:"li"},"localhost:15672")," username: guest password: guest")),(0,r.kt)("h2",{id:"code-in-platformservice---the-publisher"},"Code in PlatformService - The Publisher"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dotnet add package RabbitMQ.Client\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we add to ",(0,r.kt)("inlineCode",{parentName:"li"},"appsettings.Development.json")," ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"RabbitMQHost": "localhost",\n"RabbitMQPort": "5672"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we add to ",(0,r.kt)("inlineCode",{parentName:"li"},"appsettings.Production.json"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"RabbitMQHost": "rabbitmq-clusterip-srv",\n"RabbitMQPort": "5672"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we create ",(0,r.kt)("inlineCode",{parentName:"li"},"Dtos/PlatformPublishedDto")," This is the Event that gets pushed onto the MessageBus")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class PlatformPublishdDto {\n    public required int Id { get; set; }\n    public required string Name { get; set; }  \n    public required string Event { get; set; }\n}\n")),(0,r.kt)("h3",{id:"implementing-the-message-bus-client"},"Implementing the Message Bus Client"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we create an interface for the following RabbitMQ Message Bus implementation. ",(0,r.kt)("inlineCode",{parentName:"li"},"AsyncDataServices/IMessageBusClient.cs"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface IMessageBusClient {\n    void PublishNewPlatform(PlatformPublishdDto newCreatedPlatform);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we inject our Bus in ",(0,r.kt)("inlineCode",{parentName:"li"},"Program.cs"),'. Here as a Singleton as we assume it always stays the "same" connection.')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"builder.Services.AddSingleton<IMessageBusClient, MessageBusClient>();\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AsyncDataServices/IMessageBusClient.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class MessageBusClient : IMessageBusClient\n{\n    private readonly IConfiguration _config;\n    private readonly RabbitMQ.Client.IConnection _connection;\n    private readonly RabbitMQ.Client.IModel _channel;\n\n    public MessageBusClient(IConfiguration configuration) {\n        _config = configuration;\n        // RabbitMQ 1. wants the factory with config data \n        var factory = new RabbitMQ.Client.ConnectionFactory() {\n            HostName = _config["RabbitMQHost"],\n            Port = int.Parse(_config["RabbitMQPort"]!),\n        };\n\n        try {\n            // RabbitMQ 2. wants us to create the connection itself\n            _connection = factory.CreateConnection();\n\n            // RabbitMQ 3. wants us to create our channel\n            _channel = _connection.CreateModel();\n\n            // RabbitMQ 4. wants us to create the Exchange( in this case the fanout-type)\n            _channel.ExchangeDeclare(exchange: "trigger", type: ExchangeType.Fanout);\n\n            _connection.ConnectionShutdown += RabbitMQ_ConnectionShutdown;\n\n            Console.WriteLine("--\x3e Connected to MessageBus");\n\n        } catch (Exception e) {\n            Console.WriteLine($"--\x3e Could not connect to the Messagebus! {e.Message}");\n        }\n    }\n\n    public void PublishNewPlatform(PlatformPublishdDto newCreatedPlatformDto) {\n        var message = JsonSerializer.Serialize(newCreatedPlatformDto);\n\n        if (_connection.IsOpen) {\n            Console.WriteLine("--\x3e RabbitMQ Connection Open, sending message.");\n            SendMessage(message);\n        } else {\n            Console.WriteLine("--\x3e RabbitMQ Connection CLOSED, NOT sending!");\n        }\n    }\n\n    private void SendMessage(string message) {\n        var body = Encoding.UTF8.GetBytes(message);\n        _channel.BasicPublish(\n            exchange: "trigger", \n            routingKey: "", \n            basicProperties: null, \n            body: body);\n        \n        Console.WriteLine($"--\x3e We have sent {message}");\n    }\n    \n    // properly close ressources when this class leaves scope/dies\n    public void Dispose() {\n        Console.WriteLine("--\x3e MessageBus Disposed");\n        if (_channel.IsOpen) {\n            _channel.Close();\n            _connection.Close();\n        }\n    }\n\n    // triggers every time the connection to the Bus gets shut down\n    private void RabbitMQ_ConnectionShutdown(object? sender, ShutdownEventArgs args) {\n        Console.WriteLine($"--\x3e RabbitMQ Connection Shut Down. args={args}");\n    }\n}\n')),(0,r.kt)("h3",{id:"we-use-that-bus-to-send-in-our-controller"},"We Use that Bus to send in our Controller"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"for a first test we just spin up both Services while having Kubernetes active (for the RabbitMQ Bus)."),(0,r.kt)("li",{parentName:"ul"},"When we send a postrequest to ",(0,r.kt)("inlineCode",{parentName:"li"},"http://localhost:5062/api/platforms/")," we see in our logs for PlatformService:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'--\x3e Connected to MessageBus\ninfo: Microsoft.EntityFrameworkCore.Update[30100]\n      Saved 1 entities to in-memory store.\n// ...\n--\x3e Sync POST to CommandService was OK.\n--\x3e RabbitMQ Connection Open, sending message.\n--\x3e We have sent {"Id":4,"Name":"Docker","Event":"New_Platform_Published"}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"And a peek into the RabbitMQ manager web interface shows the recent message:\n",(0,r.kt)("img",{alt:"Alt text",src:t(9382).Z,width:"1879",height:"1027"}))),(0,r.kt)("h2",{id:"code-in-commandsservice---the-subscriber"},"Code in CommandsService - The Subscriber"),(0,r.kt)("h3",{id:"setup"},"Setup"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"add the package")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dotnet add package RabbitMQ.Client\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"add RabbitMQ-configSettings to ",(0,r.kt)("inlineCode",{parentName:"p"},"appsettings.Development.json")," and add ",(0,r.kt)("inlineCode",{parentName:"p"},"appsettings.Production.json")," like previous Service")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"we add two new Dtos: ",(0,r.kt)("inlineCode",{parentName:"p"},"Dtos/GenericEventDto.cs")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Dtos/PlatformPublishedDto.cs")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class GenericEventDto\n{\n    public required string Event { get; set; }\n}\npublic class PlatformPublishedDto \n{\n    public required int Id { get; set; }\n    public required string Name { get; set; }  \n    public required string Event { get; set; }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we add to our Mappings:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"CreateMap<PlatformPublishedDto, Platform>()\n    .ForMember(dest => dest.ExternalId, opt => opt.MapFrom(src => src.Id));\n    // Basically we want to take PlatformPublishedDto.Id and map it to our Platform.ExternalID\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we add to our ",(0,r.kt)("inlineCode",{parentName:"li"},"Data/ICommandRepo.cs"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"/// <summary>\n/// Checks if we already added this ExternalPlatform to our data. If so were synced up. Makes sure we dont duplicate data. \n/// </summary>\nbool ExternalPlatformExist(int ExternalPlatformId);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we add to our ",(0,r.kt)("inlineCode",{parentName:"li"},"Data/CommandRepo.cs"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool ExternalPlatformExist(int ExternalPlatformId)\n{\n    return _ctx.Platforms.Any(p => p.ExternalId == ExternalPlatformId);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note about Dependency Injection:")),(0,r.kt)("p",null,"The Implementation listening on our Bus will be added as a Singleton. - so for the lifetime of the app."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'That Singleton-Service will create "instances" of the EventProcessor (available via dependency-injection)'),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'so the EventProcessor MUST have a lifetime the same or greater than it\'s "parent" - so it MUST be a Singleton aswell.'),(0,r.kt)("li",{parentName:"ul"},"A Consequence of this is, that we can not inject our repository here in the constructor of EventProcessor(). Because it will only get created once.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"so we need to pass in the reference to repo another way. "))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"we add ",(0,r.kt)("inlineCode",{parentName:"p"},"EventProcessing/IEventProcessor.cs"),". Basically whenever we get an Event, we use this To Map over our Reactions. Ex we Deserialize it, add it to localPlatformsData if neccessary etc... Ignore it if its a wrong kind of Event..."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface IEventProcessor\n{\n    void ProcessEvent(string message);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"and we inject it as singleton in our main:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"builder.Services.AddSingleton<IEventProcessor, EventProcessor>();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"finally we write the implementation ",(0,r.kt)("inlineCode",{parentName:"li"},"EventProcessing/EventProcessor.cs"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class EventProcessor : IEventProcessor\n{\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly IMapper _mapper;\n\n    public EventProcessor(\n        IServiceScopeFactory scopeFactory,\n        IMapper mapper\n    )\n    {\n        _scopeFactory = scopeFactory;\n        _mapper = mapper;\n    }\n    public void ProcessEvent(string message)\n    {\n        var eventType = DetermineEvent(message);\n        switch (eventType)\n        {\n            case EventType.PlatformPublished:\n                AddPlatform(message);\n                break;\n            default:\n                break;\n        }\n    }\n\n    private EventType DetermineEvent(string notificationMessage)\n    {\n        Console.WriteLine("--\x3e Determining event");\n        var eventType = JsonSerializer.Deserialize<GenericEventDto>(notificationMessage);\n\n        if (eventType is null)\n        {\n            Console.WriteLine("--\x3e Serializing event-type wrent wrong. Is Null");\n            return EventType.Undetermined;\n        }\n\n        switch (eventType.Event)\n        {\n            case "New_Platform_Published":\n                Console.WriteLine("--\x3e New_Platform_Published event-type detected.");\n                return EventType.PlatformPublished;\n            default:\n                Console.WriteLine("--\x3e Could not determine event-type.");\n                return EventType.Undetermined;\n        }\n    }\n\n    // TODO use AddPlatform\n    private void AddPlatform(string platformPublishedMessage)\n    {\n        // use the scopeFactory to get access to our repository\n        // this is neccessary because of the different lifetimes of our repo vs our Singleton-EventProcessing\n        using (var scope = _scopeFactory.CreateScope())\n        {\n            var repo = scope.ServiceProvider.GetRequiredService<ICommandRepo>();\n            var platformPublishedDto = JsonSerializer.Deserialize<PlatformPublishedDto>(platformPublishedMessage);\n\n            try\n            {\n                var plat = _mapper.Map<Platform>(platformPublishedDto);\n                if (!repo.ExternalPlatformExist(plat.ExternalId))\n                {\n                    repo.CreatePlatform(plat);\n                    repo.SaveChanges();\n                    Console.WriteLine($" --\x3e Added Platform=[{plat.Name}] to local-Server");\n                }\n                else\n                {\n                    Console.WriteLine(" --\x3e Platform already exists in local db...");\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine($"--\x3e Could not add Platform do DB; {e.Message}");\n            }\n        }\n    }\n}\nenum EventType\n{\n    PlatformPublished,  // <= "New_Platform_Published" as Event string\n    Undetermined        // <= any other Event\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AsyncDataServices/MessageBusSubscribers.cs"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// A Background Service. A long running Task. That probably will run over the whole duration of the App. If nothing goes wrong\npublic class MessageBusSubscriber : BackgroundService\n{\n    private readonly IConfiguration _config;\n    private readonly IEventProcessor _eventProcessor;\n    private IConnection? _connection;\n    private IModel? _channel;\n    private string? _queueName;\n\n    public MessageBusSubscriber(IConfiguration config, IEventProcessor eventProcessor)\n    {\n        _config = config;\n        _eventProcessor = eventProcessor;\n        InitializeMQ();\n    }\n\n    private void InitializeMQ()\n    {\n        var factory = new ConnectionFactory()\n        {\n            HostName = _config["RabbitMQHost"],\n            Port = int.Parse(_config["RabbitMQPort"]!),\n        };\n        _connection = factory.CreateConnection();\n        _channel = _connection.CreateModel();\n        _channel.ExchangeDeclare(exchange: "trigger", type: ExchangeType.Fanout);\n        _queueName = _channel.QueueDeclare().QueueName;\n        _channel.QueueBind(queue: _queueName,\n            exchange: "trigger",\n            routingKey: "");\n\n        Console.WriteLine("--\x3e Listening on the Message Bus.");\n\n        _connection.ConnectionShutdown += RabbitMQ_ConnectionShutdown;\n    }\n\n    private void RabbitMQ_ConnectionShutdown(object? sender, ShutdownEventArgs e)\n    {\n        Console.WriteLine("--\x3e connection Shutdown");\n    }\n\n    public override void Dispose()\n    {\n        if (_channel is not null && _channel.IsOpen)\n        {\n            _channel.Close();\n            _connection?.Close();\n        }\n        base.Dispose();\n    }\n    protected override Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        stoppingToken.ThrowIfCancellationRequested();\n\n        var consumer = new EventingBasicConsumer(_channel);\n        consumer.Received += (Modulehandle, ea) => \n        {\n            Console.WriteLine("--\x3e Event Received,");\n            var body = ea.Body;\n            var notificationMessage = Encoding.UTF8.GetString(body.ToArray());\n            _eventProcessor.ProcessEvent(notificationMessage);\n        };\n        _channel.BasicConsume(queue: _queueName, autoAck: true, consumer: consumer);\n        return Task.CompletedTask;\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we inject it to our main:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"builder.Services.AddHostedService<MessageBusSubscriber>();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"now we should be able to test the whole pipeline locally. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"start both servers up"))),(0,r.kt)("li",{parentName:"ul"},"create a new Platform -> see the data hit our Subscriber:"),(0,r.kt)("li",{parentName:"ul"},"Create commands for the new platform and get those back.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},">> LOG FROM CommandsService\n--\x3e Inbound POST # Command Service\n--\x3e Event Received,\n--\x3e Determining event\n--\x3e New_Platform_Published event-type detected.\ninfo: Microsoft.EntityFrameworkCore.Update[30100]\n      Saved 1 entities to in-memory store.\n --\x3e Added Platform=[Docker] to local-Server\n")),(0,r.kt)("h2",{id:"we-publish-the-above-steps-to-kubernetes"},"We Publish the above steps to Kubernetes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// (using my Makefile)\nmake dev\n\n\n// (manually)\ndocker build -t vincepr/platformservice ./PlatformService\ndocker push vincepr/platformservice \nkubectl rollout restart deployment platforms-depl\n\ndocker build -t vincepr/commandservice ./CommandsService\ndocker push vincepr/commandservice\nkubectl rollout restart deployment commands-depl\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"now everything should be working up there.")))}u.isMDXComponent=!0},9382:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/rabbitSuccess-7104c9b73d2fb2191dbc9fe39fae53c0.png"}}]);