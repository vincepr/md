"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[1091],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=r.createContext({}),u=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(o.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),d=l,h=p["".concat(o,".").concat(d)]||p[d]||m[d]||a;return n?r.createElement(h,s(s({ref:t},c),{},{components:n})):r.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[p]="string"==typeof e?e:l,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9229:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var r=n(7462),l=(n(7294),n(3905));const a={},s="Ownership Principles",i={unversionedId:"rust/03owernership",id:"rust/03owernership",title:"Ownership Principles",description:"Stack vs Heap",source:"@site/docs/rust/03owernership.md",sourceDirName:"rust",slug:"/rust/03owernership",permalink:"/md/rust/03owernership",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/03owernership.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"some Notes while starting to learn Rust",permalink:"/md/rust/02start"},next:{title:"structure related to data",permalink:"/md/rust/04data"}},o={},u=[{value:"Stack vs Heap",id:"stack-vs-heap",level:2},{value:"Stack",id:"stack",level:3},{value:"Heap",id:"heap",level:3},{value:"Ownership",id:"ownership",level:2},{value:"Difference stack vs heap elements:",id:"difference-stack-vs-heap-elements",level:3},{value:"Variables and Data interacting with Clone",id:"variables-and-data-interacting-with-clone",level:4},{value:"Return the args back in a touple",id:"return-the-args-back-in-a-touple",level:4},{value:"References and Borrowing",id:"references-and-borrowing",level:4},{value:"Slice Type",id:"slice-type",level:4}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"ownership-principles"},"Ownership Principles"),(0,l.kt)("h2",{id:"stack-vs-heap"},"Stack vs Heap"),(0,l.kt)("h3",{id:"stack"},"Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For Fixed length elements (ex i32, Char, float...). "),(0,l.kt)("li",{parentName:"ul"},"Last In, First Out. (so we can just push and pop to it)"),(0,l.kt)("li",{parentName:"ul"},"faster"),(0,l.kt)("li",{parentName:"ul"},"When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function\u2019s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.")),(0,l.kt)("h3",{id:"heap"},"Heap"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"for elements of varrying size (ex. Strings ...)"),(0,l.kt)("li",{parentName:"ul"},"slower. Especially on allocation. Also cleanup/bookkeeping etc."),(0,l.kt)("li",{parentName:"ul"})),(0,l.kt)("h2",{id:"ownership"},"Ownership"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"each value in Rust has an owner."),(0,l.kt)("li",{parentName:"ul"},"There can only be one owner at a time."),(0,l.kt)("li",{parentName:"ul"},"When the owner goes out of scope, the value will be dropped.")),(0,l.kt)("h3",{id:"difference-stack-vs-heap-elements"},"Difference stack vs heap elements:"),(0,l.kt)("p",null,"Rust does not shallow copy elements by default. For fixed length elements it will just copy the value. For heap elements it will default to moving the value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let x = 5;\nlet y = x;      // just a copy since x is a int and just lives on the stack -> default is a copy\n\nlet s1 = String::from("hello");\nlet s2 = s1;    // here rust s1 goes out of scope; only s2 is accessible afterwards. \n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main(){\n    let s = String::from("hello");\n    let x = 10;\n    makescopy(x);\n    makescopy(x);       // x is still available since it got copied\n    takes_ownership(s); // s is "gone" after here\n}\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!("{}", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!("{}", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We can implement the ",(0,l.kt)("inlineCode",{parentName:"li"},"Copy")," trait to add this first behavior to custom types.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"similar there is a ",(0,l.kt)("inlineCode",{parentName:"li"},"Drop")," trait, for actions that need to happen if the object goes out of scope."))),(0,l.kt)("li",{parentName:"ul"},"Ways to deal with Ownership are:")),(0,l.kt)("h4",{id:"variables-and-data-interacting-with-clone"},"Variables and Data interacting with Clone"),(0,l.kt)("p",null,"to deeply copy heap data we can use the clone method."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let s1 = String::from("hello");\nlet s2 = s1.clone();\n')),(0,l.kt)("h4",{id:"return-the-args-back-in-a-touple"},"Return the args back in a touple"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n    (s2, length) = get_len(s1);\n    println!("{s2} has a length of: {length}");\n}\nfn get_len(s: String) -> (String, usize){\n    let length = s.len();\n    (s, length)\n}\n')),(0,l.kt)("h4",{id:"references-and-borrowing"},"References and Borrowing"),(0,l.kt)("p",null,"Unlike a pointer a reference is guaranteed to point to a valid value, for the life of that reference.\nThis is called borrowing. By default references are immutable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n    let len = get_len(&s1);\n    println!("{s1} has the length of: {len}");\n}\nfn get_len(s: &String) -> usize{\n    s.len()\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"mutable References:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\nfn change(s: &mut String){\n    s.push_str(", world");\n}\n')),(0,l.kt)("p",null,"Mutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value. Code that attempts to create two mutable references to s will fail. This is our saveguard against dataraces, or dangling references."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"as always we can use curly brackets to create new scope, allowing for multiple mutable references:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("hello");\n{\n    let r0 = &mut s;\n}\n// new scope so no problem\nlet r1 = &s;\nlet r2 = &s;    // only read-access so no problem\nprintln!("{} and {}", r1, r2);\n// since r1 and r2 are not used after this we can now:\nlet r3 = &mut s;    \nprintln!("{}", r2);\n\n\n')),(0,l.kt)("p",null,"Recap on Rules of References:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"At any given time, you can have either one mutable reference or any number of immutable references."),(0,l.kt)("li",{parentName:"ul"},"References must always be valid.")),(0,l.kt)("h4",{id:"slice-type"},"Slice Type"),(0,l.kt)("p",null,"slices let you refernce a contiguous sequence of elements in a collection rather than the whole collection. A slice is a reference and thus has no ownership."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("hello world");\nlet len = s.len();\n\nlet hello1 = &s[0..5];      // start_index is inclusive; end_index is exclusive\nlet hello2 = &s[..5];       // same as above\n\nlet world1 = &s[6..11];\nlet world2 = &s[6..len];\nlet world3 = &s[6..];       // all 3 the same\n\nlet s2 = &s[..]             // whole string\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"CAREFUL: indexes must occur at valid utf8 boundaries. And ",(0,l.kt)("em",{parentName:"li"},"multibyte")," characters exist in utf8!")),(0,l.kt)("p",null,"deref coercions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'// get_first_word(s: &String) -> &str // would only allow Strings as args\n// the below allows both string literals and Strings and slices of those as args.\nfn get_first_word(s: &str)-> &str{\n    let bytes = s.as_bytes();\n    \n    for (idx, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..idx];\n        }\n    }\n}\nfn main() {\n    let my_string = String::from("hello world");\n    let my_string_literal = "hello world";\n\n    let word = get_first_word(&my_string[0..6]);\n    let word = get_first_word(&my_string[..]);\n    let word = get_first_word(&my_string);\n\n    let word = get_first_word(&my_string_literal[0..6]);\n    let word = get_first_word(&my_string_literal[..]);\n    let word = get_first_word(&my_string_literal);\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"other slices")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let a = [1,2,3,4,5];\nlet slice = &a[1..3];\nassert_eq!(slice, &[2,3]);\n")))}p.isMDXComponent=!0}}]);