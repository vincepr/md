"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[3637],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,f=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return t?r.createElement(f,o(o({ref:n},u),{},{components:t})):r.createElement(f,o({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9816:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(7462),a=(t(7294),t(3905));const i={},o="Exercises",l={unversionedId:"go/exercises",id:"go/exercises",title:"Exercises",description:'- Exercises from the "A Tour of Go" Golang intro',source:"@site/docs/go/exercises.md",sourceDirName:"go",slug:"/go/exercises",permalink:"/md/go/exercises",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/go/exercises.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"wirtschaft_grundlagen",permalink:"/md/fiae/wirtschaft_grundlagen/"},next:{title:"notes while learning golang",permalink:"/md/go/intro"}},s={},c=[{value:"Exercise: Loops and Functions",id:"exercise-loops-and-functions",level:2},{value:"Exercise:Slices",id:"exerciseslices",level:2},{value:"Exercise: Maps",id:"exercise-maps",level:2},{value:"Exercise: Fibonacci closure",id:"exercise-fibonacci-closure",level:2},{value:"Exercise: rot13Reader",id:"exercise-rot13reader",level:2},{value:"Exercise: Readers",id:"exercise-readers",level:3},{value:"Exercise: Images",id:"exercise-images",level:3},{value:"Exercise Equivalent Binary Trees",id:"exercise-equivalent-binary-trees",level:3},{value:"Exercise: Web Crawler",id:"exercise-web-crawler",level:3}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"exercises"},"Exercises"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Exercises from the "A Tour of Go" Golang intro')),(0,a.kt)("h2",{id:"exercise-loops-and-functions"},"Exercise: Loops and Functions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\nfunc Sqrt(x float64) float64 {\n    z := float64(x*x)\n    for i:=0; i<10; i++{\n        diff := (z*z-x) / (2*z)\n        z = z-diff\n        if diff<0.000000001{\n            break\n            }\n    }\n    return z\n}\n\nfunc main() {\n    in := 10.0\n    fmt.Println("Methods diverge by:", Sqrt(in)- math.Sqrt(in))\n}\n')),(0,a.kt)("h2",{id:"exerciseslices"},"Exercise:Slices"),(0,a.kt)("p",null,"Implement Pic. It should return a slice of length dy, each element of which is a slice of dx 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values."),(0,a.kt)("p",null,"The choice of image is up to you. Interesting functions include (x+y)/2, x*y, and x^y."),(0,a.kt)("p",null,"(You need to use a loop to allocate each []uint8 inside the ","[][]","uint8.)"),(0,a.kt)("p",null,"(Use uint8(intValue) to convert between types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\nimport (\n    "golang.org/x/tour/pic"\n)\n\n// makes a dx by dy large field of 8 bit unsigned slices to "draw" a picture.\nfunc Pic(dx, dy int) [][]uint8 {\n    var p [][]uint8 = make([][]uint8, dy)\n    //allocate al []unit8s:\n    for i := 0; i < dy; i++ {\n        p[i] = make([]uint8, dx)\n    }\n\n    for x := 0; x < dx; x++ {\n        for y := 0; y < dy; y++ {\n            // p[x][y] = uint8((x+y)/2) // gradient towards corner\n            // p[x][y] = uint8(x*y)     // fractals\n            \n            gradX := (x-255)            // cross-"ish":\n            if x<dx/2{gradX=255-x}\n            gradY := (y-255)\n            if y<dy/2{gradY=255-y}\n            \n            p[x][y] = uint8(gradY+gradX)\n        }\n    }\n\n    return p\n}\n\nfunc main() {\n    pic.Show(Pic)\n}\n')),(0,a.kt)("h2",{id:"exercise-maps"},"Exercise: Maps"),(0,a.kt)("p",null,"Implement WordCount. It should return a map of the counts of each \u201cword\u201d in the string s. The wc.Test function runs a test suite against the provided function and prints success or failure."),(0,a.kt)("p",null,"You might find strings.Fields helpful."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\nimport (\n    "golang.org/x/tour/wc"\n    "strings"\n)\n\nfunc WordCount(s string) map[string]int {\n    m := make( map[string] int)\n    words := strings.Fields(s)\n    \n    for _, word := range words {\n        _, ok := m[word]\n        if ok {                 //if same word more than twice\n            m[word] ++\n        } else{\n            m[word] = 1\n        }\n    }\n    return m\n}\n\nfunc main() {\n    wc.Test(WordCount)\n}\n')),(0,a.kt)("h2",{id:"exercise-fibonacci-closure"},"Exercise: Fibonacci closure"),(0,a.kt)("p",null,"Let's have some fun with functions."),(0,a.kt)("p",null,"Implement a fibonacci function that returns a function (a closure) that returns successive fibonacci numbers (0, 1, 1, 2, 3, 5, ...)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"")),(0,a.kt)("h2",{id:"exercise-rot13reader"},"Exercise: rot13Reader"),(0,a.kt)("p",null,"A common pattern is an io.Reader that wraps another io.Reader, modifying the stream in some way."),(0,a.kt)("p",null,"For example, the gzip.NewReader function takes an io.Reader (a stream of compressed data) and returns a *gzip.Reader that also implements io.Reader (a stream of the decompressed data)."),(0,a.kt)("p",null,"Implement a rot13Reader that implements io.Reader and reads from an io.Reader, modifying the stream by applying the rot13 substitution cipher to all alphabetical characters."),(0,a.kt)("p",null,"The rot13Reader type is provided for you. Make it an io.Reader by implementing its Read method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-Go",metastring:"{13-23}","{13-23}":!0},"package main\nimport (\n    \"io\"\n    \"os\"\n    \"strings\"\n)\n\ntype rot13Reader struct {\n    r io.Reader\n}\n\nfunc (reader rot13Reader) Read(bytes []byte) (int, error) {\n    n, err := reader.r.Read(bytes)\n    for i, val := range bytes[:n] {\n        if val >= 'a' && val <= 'z' {\n            bytes[i] = (val-'a'+13)%26 + 'a'\n        } else if val >= 'A' && val <= 'Z' {\n            bytes[i] = (val-'A'+13)%26 + 'A'\n        }\n    }\n    return n, err\n}\n\nfunc main() {\n    s := strings.NewReader(\"Lbh penpxrq gur pbqr!\")\n    r := rot13Reader{s}\n    io.Copy(os.Stdout, &r)\n}\n")),(0,a.kt)("h3",{id:"exercise-readers"},"Exercise: Readers"),(0,a.kt)("p",null,"Implement a Reader type that emits an infinite stream of the ASCII character 'A'."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"")),(0,a.kt)("h3",{id:"exercise-images"},"Exercise: Images"),(0,a.kt)("p",null,"Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of image.Image instead of a slice of data."),(0,a.kt)("p",null,"Define your own Image type, implement the necessary methods, and call pic.ShowImage."),(0,a.kt)("p",null,"Bounds should return a image.Rectangle, like image.Rect(0, 0, w, h)."),(0,a.kt)("p",null,"ColorModel should return color.RGBAModel."),(0,a.kt)("p",null,"At should return a color; the value v in the last picture generator corresponds to color.RGBA{v, v, 255, 255} in this one."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"")),(0,a.kt)("h3",{id:"exercise-equivalent-binary-trees"},"Exercise Equivalent Binary Trees"),(0,a.kt)("p",null,"Exercise: Equivalent Binary Trees"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Implement the Walk function.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Test the Walk function."))),(0,a.kt)("p",null,"The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values k, 2k, 3k, ..., 10k."),(0,a.kt)("p",null,"Create a new channel ch and kick off the walker:"),(0,a.kt)("p",null,"go Walk(tree.New(1), ch)\nThen read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10."),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Implement the Same function using Walk to determine whether t1 and t2 store the same values.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Test the Same function."))),(0,a.kt)("p",null,"Same(tree.New(1), tree.New(1)) should return true, and Same(tree.New(1), tree.New(2)) should return false."),(0,a.kt)("p",null,"The documentation for Tree can be found here."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"")),(0,a.kt)("h3",{id:"exercise-web-crawler"},"Exercise: Web Crawler"),(0,a.kt)("p",null,"In this exercise you'll use Go's concurrency features to parallelize a web crawler."),(0,a.kt)("p",null,"Modify the Crawl function to fetch URLs in parallel without fetching the same URL twice."),(0,a.kt)("p",null,"Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"")))}p.isMDXComponent=!0}}]);