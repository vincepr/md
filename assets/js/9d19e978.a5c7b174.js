"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[4432],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>p});var n=t(7294);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=n.createContext({}),c=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},u=function(e){var a=c(e.components);return n.createElement(o.Provider,{value:a},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},g=n.forwardRef((function(e,a){var t=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),g=l,p=d["".concat(o,".").concat(g)]||d[g]||m[g]||i;return t?n.createElement(p,r(r({ref:a},u),{},{components:t})):n.createElement(p,r({ref:a},u))}));function p(e,a){var t=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=g;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s[d]="string"==typeof e?e:l,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},6364:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=t(7462),l=(t(7294),t(3905));const i={},r="Writing EntityFramework Linq-Queries",s={unversionedId:"csharp/examples/EFLinqQueries",id:"csharp/examples/EFLinqQueries",title:"Writing EntityFramework Linq-Queries",description:"The Data for the following examples",source:"@site/docs/csharp/examples/EFLinqQueries.md",sourceDirName:"csharp/examples",slug:"/csharp/examples/EFLinqQueries",permalink:"/md/csharp/examples/EFLinqQueries",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/csharp/examples/EFLinqQueries.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Delegates in Csharp",permalink:"/md/csharp/examples/Delegate"},next:{title:"EntityFramework - best practices",permalink:"/md/csharp/examples/EntityFramework"}},o={},c=[{value:"The Data for the following examples",id:"the-data-for-the-following-examples",level:2},{value:"Adding Data",id:"adding-data",level:2},{value:"Selecting Data",id:"selecting-data",level:2},{value:"update and deleteing of data",id:"update-and-deleteing-of-data",level:2},{value:"Advanced",id:"advanced",level:2},{value:"Relations between Tables",id:"relations-between-tables",level:2},{value:"adding a base domain object for repeating fields",id:"adding-a-base-domain-object-for-repeating-fields",level:2},{value:"n to m relations - many to many relations",id:"n-to-m-relations---many-to-many-relations",level:2},{value:"Querying data from multiple tables at once",id:"querying-data-from-multiple-tables-at-once",level:3},{value:"Anonymous data types",id:"anonymous-data-types",level:2},{value:"Raw Sql in EF",id:"raw-sql-in-ef",level:2},{value:"interacting with a view in EF",id:"interacting-with-a-view-in-ef",level:3},{value:"executing raw sql",id:"executing-raw-sql",level:3},{value:"Adding and executing a stored procedure",id:"adding-and-executing-a-stored-procedure",level:3},{value:"Seed Data",id:"seed-data",level:2},{value:"Change tracking -",id:"change-tracking--",level:2},{value:"Constraints and Default Values - with fluent api",id:"constraints-and-default-values---with-fluent-api",level:2},{value:"resilient connections - retry policies",id:"resilient-connections---retry-policies",level:2}],u={toc:c};function d(e){let{components:a,...t}=e;return(0,l.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"writing-entityframework-linq-queries"},"Writing EntityFramework Linq-Queries"),(0,l.kt)("h2",{id:"the-data-for-the-following-examples"},"The Data for the following examples"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'private class OurDbContext : DbContext\n{\n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {\n        optionsBuilder\n            .UseSqlServer("Data Source=(localdb)\\\\MSSQLLocalDB; Initial Catalog=FootballLeage_EFCore")\n            // Enable explicit loging if executed sql-queries\n            .LogTo(Console.WriteLine, new[] { DbLoggerCategory.Database.Command.Name}, LogLevel.Information)\n            // Disable automatic redacting\n            .EnableSensitiveDataLogging();\n    }\n\n    public DbSet<Teams> Teams { get; set; }\n    public DbSet<League> Leagues { get; set; }\n}\n\npublic class Team {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int LeagueId { get; set; }\n    public virtual League League { get; set; }\n}\n\npublic class League {\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n')),(0,l.kt)("h2",{id:"adding-data"},"Adding Data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'OurDbContext ctx = new OurDbContext();\n\n// synchronous:\nvar euro = new League { Name = "Europameisterschaft" };\nctx.Leagues.Add(euro);\n// async\nawait ctx.Leagues.AddAsync(new League { Name = "Bundesliega" });\n\n// up to now changes just happened in memory. Persist them:\nctx.SaveChanges();\n\nAddTeamsToLeague();\nawait ctx.SaveChangesAsync(ctx, euro);\n\nstatic async Task AddTeamsToLeague(OurDbContext ctx, League league) {\n    var teams = new List<Team>\n    {\n        new Team {\n            Name = "Redbull Leipzig",\n            // using the "reference by id" to the league\n            LeagueId = league.Id,\n        },\n        new Team {\n            Name = "Fc Bayern",\n            LeagueId = league.Id,\n        },\n        new Team {\n            Name = "VfL Wolfsburg",\n            // using the actual object of the league\n            League = league,\n        }\n    };\n    await ctx.AddRangeAsync(teams);\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"EFCore will translate between using the actual League object vs the LeagueId and resolve those to the same sql-queries under the hood.")),(0,l.kt)("p",null,"In the following example we only explicitly add the team. The new league gets added implicit."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the sql-querys executed will be league first then the team (as neccesary for sql-server)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var legue = new Legue {Name = "English Soccer"};\nvar team = new Team {Name = "Manchester", League = legue};\nawait ctx.Leagues.AddSync(legue);\nawait ctx.SaveChangesAsync();\n')),(0,l.kt)("h2",{id:"selecting-data"},"Selecting Data"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"retrieving data")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'// BAD - here we have have a refernce to the DbSet, no sql-querry has ran so far\nvar badAllLeagues = ctx.Legues;\n// here the sql-querry will run.\nforeach (var l in leagues) {\n    Console.WriteLine($"{league.Name}");    // the "bad" thing here is that:\n    // the db-connection will stay open for the whole duration of the loop\n}\n\n// GOOD - in the next line on the other hand we directly run the "select * from leagues"\nvar allLeagues = ctx.Legues.ToList();\nforeach (var l in leagues) {                // at this line the db-connection is already closed\n    Console.WriteLine($"{league.Name}");    // and everything happens in memory. \n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"filtering data")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var leagues = await ctx.Leagues.Where(l => l.Name =="Bundesliega").ToListAsync();\nvar teams = await ctx.Teams.Where(t => t.Name.Contains("Bayern")).ToListAsync();\n// we can use SQL-Native: sql-"LIKE" or sql-"Contains" with the EF.Functions.\nvar teams2 = await ctx.Teams.Where(t => EF.Functions.Like(t.Name, "%Wolfs%"));\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'// firstOrDefault is expecting a list and will pick the first:\nvar first     = await ctx.Leagues\n    .Where(l => l.Name.Contains("A"))\n    .FirstOrDefaultAsync();\nvar alsofirst = await ctx.Leagues\n    .FirstOrDefaultAsync(l => l.Name.Contains("A"));\n\n// single is expacting EXACTLY one and will throw/null if multiple matches are found\nvar single   = await ctx.Leagues\n    .Where(l => l.Name.Contains("c"))\n    .SingleAsync();\nvar wontThrow = await ctx.Leagues\n    .Where(l => l.Name.Contains("c"))\n    .SingleOrDefaultAsync();\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"aggregate functions:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"var leagues = ctx.Leagues;\nvar count = await leagues.CountAsync();         // SELECT COUNT(*)      -> int\nvar longCount = await leagues.LongCountAsync(); // SELECT COUNT_BIG(*)  -> int64\nvar min = await leagues.MinAsync();\nvar max = await leagues.MaxAsync();\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"find by primary key (benefit of beeing fast)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"var f = await leagues.FindAsync(2); // where Id==2;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"alternative syntax:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var teams = from i in ctx.Teams select i;   // select * from teams\nvar same = await (from i in ctx.Teams select i).ToListAsync();\n\nvar teams2 =    from i in ctx.Teams\n                where i.Name="Fc Bayern"\n                select i.Id;\n\n')),(0,l.kt)("h2",{id:"update-and-deleteing-of-data"},"update and deleteing of data"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"update")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var team = ctx.Teams.Find(2);\nleague.Name = "Newname";\nctx.SaveChanges();\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"delete",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"by default Ef will generate relationships with on delete cascade.")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var listOfTeams = ctx.Teams.Where(t => t.Name=="Newname");\nctx.Teams.RemoveRange(listOfTeams);\n\nvar team = ctx.Teams.Find(2);\nctx.Team.Remove(team);\n')),(0,l.kt)("h2",{id:"advanced"},"Advanced"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"AsNoTracking - in a scenario where we need reaonly data this releases data quicker,\nsince EFCore does't have to keep track if the object gets changed etc.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var withTrackingIsTheDefault = ctx.Teams.FirstOrDefault(q => q.Id == 2);\nvar withNoTracking = ctx.Teams.AsNoTracking().FirstOrDefault(q => q.Id == 2);\n\nwithTrackingIsTheDefault.Name = "this will get written in the db";\nwithNoTracking = "this change never touches our db";\n\nvar entriesBefore = ctx.ChangeTracker.Entries();    // breakpoint here\nctx.SaveChanges();\nvar entriesAfter = ctx.ChangeTracker.Entries();     // breakpoint here\n')),(0,l.kt)("h2",{id:"relations-between-tables"},"Relations between Tables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Team {\n    //...\n    // here the foreign key is not nullable -> so will default on delte cascade when that table is removed etc.\n    public int LeagueId { get; set; }\n\n    // here on the other hand the Team can exists without a corresponding League. (on delete restrict would be generated etc...)\n    public int? LeagueId { get; set; }\n\n    // this by it's own would also generate a nullable foreign reference\n    public virtual League League { get; set; }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"instead of having to write a manual query for all Teams of one league (would have to use a join) EF provides:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class League {\n    // easy way to access corresponding teams for each League.\n    public List<Team> Teams { get; set; }   // ICollection IEnumerable would also work the same\n}\n")),(0,l.kt)("h2",{id:"adding-a-base-domain-object-for-repeating-fields"},"adding a base domain object for repeating fields"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"fields like id, created by, updated at, created at, that many/all tables should have, it makes sense to layer them out to a base-object:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public abstract class BaseDomainObject {\n    public int Id { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n")),(0,l.kt)("h2",{id:"n-to-m-relations---many-to-many-relations"},"n to m relations - many to many relations"),(0,l.kt)("p",null,"adding to the above example: hometeam vs awayteam having one or many matches."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"so the same table is relating to another table twice:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Match: BaseDomainObject {\n    // for the following 2 References we broke away from default naming conventions. (Home-/Away-TeamId).\n    // EF will not be able to automatically infer the relatin now:\n    public int HomeTeamId { get; set; }\n    public int AwayTeamId { get; set; }\n\n    public virtual Team HomeTeam { get; set; }\n    public virtual Team AwayTeam { get; set; }\n\n    public DateTime Date { get; set; }\n    public int HomeTeamResult { get; set; }\n    public int AwayTeamResult { get; set; }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Team : BaseDomainObject {\n    public string Name { get; set; }\n    public int LeagueId { get; set; }\n    public virtual League League { get; set; }\n\n    public virtual Coach Coach { get; set; }\n\n    // again not neccessary, but to make querying matches of a specific team easier:\n    public virtual List<Match> HomeMatches { get; set; }\n    public virtual List<Match> AwayMatches { get; set; }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here the relation can not be infered by names alone so we have to be explicit about the foreign relation between the tables:"),(0,l.kt)("li",{parentName:"ul"},"the way this is done is by using the fluent api EF provides.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"})))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class MyDbContext : DbContext {\n    // ....\n    protected override void OnModelCreating(ModelBuilder modelBuilder) {\n        modelBuilder.Entity<Team>()\n            // here each line builds on the next:\n            .HasMany(team => team.HomeMatches)  // one team has many HomeMatches\n            .WithOne(match => match.HomeTeam)   // witch each HomeMatch having ONE HomeTeam\n            .HasForeignKey(m => m.HomeTeamId)   // and corresponding FK is HomeTeamId\n            .IsRequired()\n            .OnDelte(DeleteBehavior.Restrict); // can not delete a team unless all Matches have been removed before.\n        \n        modelBuilder.Entity<Team>()\n            .HasMany<Team>(t => team.AwayTeam)\n            .WithOne(m => m.AwayTeam)\n            .HasForeignKey(m => m.AwayTeamId)\n            .IsRequired()\n            .OnDelete(DeleteBehavior.Restrict);\n    }\n\n    public DbSet<Team> Teamms { get; set; }\n    public DbSet<Leagues> Leagues { get; set; }\n    public DbSet<Matches> Matches { get; set; }\n    public DbSet<Coach> Coaches { get; set; } \n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Coach : BaseDomainObject {\n    public string Name { get; set; }\n    public int? Team { get; set; } // coach can exist without training a team currently\n    // and again the (unncessary) direct reference for convenience\n    public virtual Team Team { get; set; }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"insert works as expected")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'var newMatches = new List<Match> {\n    new Match {AwayTeamId=1, HomeTeamId=2, Date= new DateTime(2023,4,22)},\n    new Match {AwayTeamId=8, HomeTeamId=2, Date= DateTime.Now}\n};\n\nvar coachFcBayern = new Coach {Name = "James Bond", TeamdId = 3};\nvar unemployedCoach = new Coach { Name = "Somebody" }; \n\nawait ctx.AddRangeAsync(newMatches);\nawait ctx.AddAsync(coachFcBayern);\nawait ctx.AddAsync(unemployedCoach);\nawait ctx.SaveChangesAsync();\n')),(0,l.kt)("h3",{id:"querying-data-from-multiple-tables-at-once"},"Querying data from multiple tables at once"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'// Get many related records:\nvar leagues = ctx.Leagues.Include(l => l.Teams).ToList();\n\n// Get one related record:\nvar team = ctx.Teams.Include(t => t.Coach).FirstOrDefault(t => t.Id==3);\n\n// Complex queries\n// - we can do complex joins and nest them. \n// - .Includes() will refer to the "root" Teams and join ontop that\n// - while each .ThenIncludes() works on the previously "included" join\nvar teamWithMatchesAndOpponents = ctx.Teams\n    .Include(t => t.AwayMatches).ThenInclude(t => t.HomeTeam).ThenInclude(t => t.Coach)\n    .ThenInclude(t => t.HomeTeam).ThenInclude(t => t.AwayTeam)\n    .FirstOrDefault(t => t.Id == 1);\n\n// filtering. All teams with Home matches:\nvar teams = ctx.Teams\n    .Where(t => t.HomeMatches.Count > 0)\n    .Include(t => t.Coach)\n    .ToList();\n\n// filtering with related data. Ex i know part of a team and i want to know what league that team is in:\nvar leagues = ctx.Leagues\n    .Where(l => l.Teams.Any(t => t.Name.Contains("Bayern")))\n    .toList();\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"another quick example for a n to m relation:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Student {\n    public int StudentId { get; set; }\n    public string StudentName { get; set; }\n    public virtual ICollection<Course> Courses { get; set; }\n}\n\npublic class Course {\n    public int CourseId { get; set; }\n    public string CourseName { get; set; }\n    public virtual ICollection<Student> Students { get; set; }\n}\n\npublic class SchoolDbContext : DbContext {\n    modelBuilder.Entity<Student>()\n        .HasMany<Cource>(s => s.Cources)\n        .WithMany(c => c.Students)\n        .Map(cs => {\n            cs.MapLeftKey("StudentRefId");\n            cs.MapRightKey("CourceRefId");\n            cs.ToTable("StudentCourse");\n        });\n}\n')),(0,l.kt)("h2",{id:"anonymous-data-types"},"Anonymous data types"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"List<string> teamNames = ctx.Teams.Select(t => t.Name).ToList();\n\n// touples:\nvar teamsT = ctx.Teams.Include(t => t.Coach).Select(t => (t.Name, t.Id)).ToList();\n// anonymous obj:\nvar teamsO = ctx.Teams.Include(t => t.Coach).Select(t => new {\n    TeamName = t.Name, CoachName = t.Coach.Name\n    }).ToList();\nvar teams = ctx.\n")),(0,l.kt)("h2",{id:"raw-sql-in-ef"},"Raw Sql in EF"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we want to add a sql-function and an sql-view but still benefit from adding it with our migrations (eg we can roll them back etc...)")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"We create an empty migration (without any changes that would generate code)"),(0,l.kt)("li",{parentName:"ol"},"When we check the Migration generated it should look like this:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public partial class AddingTeamDetailsViewAndEarlyMatchFunction : Migration\n{\n    protected override void Up(MigrationBuilder migrationBuilder) \n    {\n\n    }\n    protected override void Down(MigrationBuilder migrationBuilder) \n    {\n\n    }\n}\n")),(0,l.kt)("ol",{start:3},(0,l.kt)("li",{parentName:"ol"},"We add our manually created sql:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public partial class AddingTeamDetailsViewAndEarlyMatchFunction : Migration\n{\n    protected override void Up(MigrationBuilder migrationBuilder) \n    {\n        migrationBuilder.Sql(@"CREATE FUNCTION [dbo].[GetEarliestMatch] (@teamId int)\n                                RETURNS datetime\n                                BEGIN\n                                    DECLARE @result datetime\n                                    SELECT TOP 1 @result = date\n                                    FROM [dbo].[Matches]\n                                    order by Date\n                                    return @result\n                                END");\n        migrationBuilder.Sql(@"CREATE VIEW [dbo].[TeamsCoachesLeagues]\n                                AS\n                                SELECT t.Name, c.Name AS CoachName, l.Name AS LeagueName\n                                FROM dbo.Teams AS t LEFT OUTER JOIN\n                                    dbo.Coaches AS c ON t.Id = c.Team.Id INNER JOIN\n                                    dbo.Leagues AS l ON t.LeagueId = l.Id");\n    }\n    protected override void Down(MigrationBuilder migrationBuilder) \n    {\n        // we MUST also manually add the drop statements to rollback:\n        migrationBuilder.Sql("@DROP VIEW [dbo].[TeamscoachesLeagues]");\n        migrationBuilder.Sql("@DROP Function [dbo].[GetEarliestMatch]");\n    }\n}\n')),(0,l.kt)("h3",{id:"interacting-with-a-view-in-ef"},"interacting with a view in EF"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we create a new DataClass that corresponds with the already existing view:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public class TeamsCoachesLeaguesView {\n    public string Name { get; set; }\n    public string CoachName { get; set; }\n    public string LeagueName { get; set; }\n}\n\n// we must also add it to our dbContext:\npublic class MyDbContext : DbContext {\n    protected override void OnModelCreating(ModelBuilder modelBuilder) {\n        modelBuilder.Entity<TeamsCoachesLeaguesView>()\n            .HasNoKey()    // We MUST explicitly tell EF that this is a kekyless view\n            .ToView("TeamsCoachesLeagues"); // just to make sure EF correctly maps this to the view and doesnt try to create a new table\n            }\n    public DbSet<TeamsCoachesLeaguesView> TeamsCoachesLeagues { get; set; }\n}\n\n// now we can use it "just like a table"\nvar details = ctx.TeamsCoachesLeagues.ToList();\n')),(0,l.kt)("h3",{id:"executing-raw-sql"},"executing raw sql"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"selects with raw sql are really limited:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'// this is not guarded against SQl-Injections!\n// - also .FromSqlRaw has to return the whole dataset that matches to the Teams-object\n//    so "SELECT *" will work "SELECT Name, Id" not because it is missing some Teams-object attributes\nvar teams1 = ctx.Teams.FromSqlRaw("SELECT * FROM Teams").ToList();\n\n// this is save against sql-injections. But still has the above limitations.\nvar name = "Fc Bayern";\nvar teams2 = ctx.Teams.FromSqlInterpolated($"SELECT * FROM Teams where name={name}").ToListAsync();\n')),(0,l.kt)("h3",{id:"adding-and-executing-a-stored-procedure"},"Adding and executing a stored procedure"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"again we write our own migration:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public partial class AddingTeamDetailsViewAndEarlyMatchFunction : Migration\n{\n    protected override void Up(MigrationBuilder migrationBuilder) \n    {\n        migrationBuilder.Sql(@"CREATE PROCEDURE sp_DeleteTeamById\n                                @teamId int\n                            AS\n                            BEGIN\n                                Delete from Teams where Id = @teamId\n                            END");\n    }\n    protected override void Down(MigrationBuilder migrationBuilder) \n    {\n        migrationBuilder.Sql(@"DROP PROCEDURE [dbo].[sp_DeleteTeamById]");\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'static void ExecuteNonQueryCommand() {\n    // BAD (again not guared against sql-injection)\n    var teamId = 2;\n    var affectedRows = ctx.Database.ExecuteSqlRaw("exec sp_DeleteTeamById {0}", teamId);\n    \n    // again the better variant:\n    var teamId2 = 3;\n    var affectedRows2 = ctx.Database.ExecuteSqlInterpolated($"exec sp_DeleteTeamById {teamId2}");\n}\n\nstatic void ExecuteStoredProcedure() {\n    var teamId = 4;\n    result = ctx.Coaches.FromSqlRaw("EXEC dbo.sp_GetTeamCoach {0}, teamId").ToList();\n}\n')),(0,l.kt)("h2",{id:"seed-data"},"Seed Data"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Default data",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"either for testing in a dev environment"),(0,l.kt)("li",{parentName:"ul"},"to create some default data like a list of all supported Languages etc...")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public class MyDbContext : DbContext {\n    //...\n    protected override void OnModelCreating(ModelBuilder modelBuilder) {\n        modelBuilder.Entity<League>()\n            .HasData(\n                new League{ Id=1, Name="Bundesliega" } \n            )\n        modelBuilder.Entity<Coach>()\n            .HasData(\n                new Team { Id=1, Name="Fc Bayern", LeagueId=1},\n                new Team { Id=2, Name="Redbull Leipzig", LeagueId=1},\n            );\n        // to be a bit more cleaner we can extract all of this out:\n        modelBuilder.ApplyConfiguration(new CoachSeedConfiguration()):\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public class CoachSeedConfiguration : IEntityTypeConfiguration<Coach> {\n    public void Configure(EntityTypeBuilder<Coach> builder) {\n        builder.HasData(\n            new Coach { Id=20, Name="Rob Stark", TeamId=1},\n            new Coach { Id=21, Name="Sansa Stark", TeamId=2},\n        )\n    }\n}\n')),(0,l.kt)("h2",{id:"change-tracking--"},"Change tracking -"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we override what happens when changes get saved.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"we can use this to for example add runtime checking of certain constraints")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public abstract class BaseDomainObject {\n    public DateTime CreatedDate { get; set; }\n    public DateTime ModifiedDate { get; set; }\n    public User CreatedBy { get; set; }\n    public User ModifiedBy { get; set; }\n}\n\npublic class MyDbContext : DbContext {\n    protected override async Task<int> SaveChangesAsync(CancellationToken cancellationToken=default) {\n\n        // A list of Entries(in memory) that will get written to the db:\n        ChangeTracker.Entries();\n\n        // we have a few enums to check for state data is in:\n        // EntityState.Unchanged | Added | Detached | Modified | Deleted\n\n        var modifiedEntires = ChangeTracker.Entries()\n            .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);\n        \n        foreach(var entry in modifiedEntries) {\n            var e = (BaseDomainObject)entry.Entity;\n            e.ModifiedDate = DateTime.Now;\n            e.ModifiedBy = User.Current();\n\n            if (entry.State == EntityState.Added) {\n                e.CreatedDate = DateTime.Now;\n                e.CreatedBy = User.Current();\n            }\n        }\n        return base.SaveChangesAsync(cancellationToken);\n    }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we have to be minful here when overriding SaveChangesAsync() we ONLY override this one Function.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"And SaveChangesAsync(CancellationToken c), SaveChanges(), SaveChanges(CancellationToken c) might not be targeted by our custom logic.")))),(0,l.kt)("h2",{id:"constraints-and-default-values---with-fluent-api"},"Constraints and Default Values - with fluent api"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"public MyDbContext : DbContext {\n    protected override void OnModelCreating(ModelBuilder modelBuilder) {\n        modelBuilder.Entity<Team>()\n            .Property(t => t.Name).HasMaxLength(50);\n        \n        // we can tell EF to create index tables -> high speed lookup by this row:\n        modelBuilder.Entity<League>()\n            .HasIndex(l => l.Name);\n        \n        // enforcing a value to be unique:\n        modelBuilder.Entity<League>()\n            .Property(l => l.Name).IsUnique();\n        \n        // enforcing a combination of values to be unique:\n        modelBuilder.Entity<Coach>()\n            .HasIndex(c => new { c.Name, c.TeamId}).IsUnique();\n        \n    }\n}\n")),(0,l.kt)("h2",{id:"resilient-connections---retry-policies"},"resilient connections - retry policies"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"packets might be dropped, actions might fail.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'public MyDbContext : DbContext {\n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {\n        optionsBuilder.UseSqlServer("connectionstring", sqlOptions => {\n            sqlOptions.EnableRetryOnFailure(\n                maxRetryCount: 5, \n                maxRetryDelay: TimeSpan.Fromseconds(30),\n                errorNumversToAdd: null,\n                )\n        });\n    }\n}\n')))}d.isMDXComponent=!0}}]);