"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[4782],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,g=d["".concat(l,".").concat(m)]||d[m]||c[m]||a;return t?r.createElement(g,i(i({ref:n},u),{},{components:t})):r.createElement(g,i({ref:n},u))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=t(7462),o=(t(7294),t(3905));const a={},i="Reverse Proxy with Login",s={unversionedId:"go/03examples/reverseProxy",id:"go/03examples/reverseProxy",title:"Reverse Proxy with Login",description:"minimal example of a reverse proxy to put our app(s) behind so we can use one login for it all.",source:"@site/docs/go/03examples/reverseProxy.md",sourceDirName:"go/03examples",slug:"/go/03examples/reverseProxy",permalink:"/md/go/03examples/reverseProxy",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/go/03examples/reverseProxy.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Syncronizing read/write - mutex in a Game example",permalink:"/md/go/03examples/game"},next:{title:"Timeout - Context package",permalink:"/md/go/03examples/timeoutFetch"}},l={},p=[{value:"golang - server",id:"golang---server",level:2}],u={toc:p};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reverse-proxy-with-login"},"Reverse Proxy with Login"),(0,o.kt)("p",null,"minimal example of a reverse proxy to put our app(s) behind so we can use one login for it all."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"This is just a early snapshot, before implementing jwt, env-secret...")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Only using standard library packages, vanilla js")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"this just exists to build upon, or as a quick reminder to refresh my memory"))),(0,o.kt)("h2",{id:"golang---server"},"golang - server"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"./main.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "flag"\n    "fmt"\n    "log"\n    "net/http"\n    "net/http/httputil"\n    "net/url"\n    "strings"\n    "time"\n)\n\n/*\n* SETUP - initializing defaults and checking urls\n */\nvar (\n    port        = flag.String("port", "3002", "the port this proxy should listen for requets from")\n    name        = flag.String("name", "vince", "the address and port of the server we proxy to")\n    password        = flag.String("pw", "123", "the address and port of the server we proxy to")\n    urlProxy    = flag.String("url", "http://127.0.0.1:3001", "the address and port of the server we proxy to")\n    \n)\nconst cookieToken string  = "123asdfasdoi123"\n\n// read env values, atm just using flags -port -url etc\nfunc getEnvValues() {\n    flag.Parse()\n    formatUrl := func(str *string){\n        if !strings.HasPrefix(*str, "http://") && !strings.HasPrefix(*str, "https://"){\n            *str = "http://" + *str\n            log.Println("adding http:// str the URL -str:", *str)\n        }\n    }\n    formatUrl(urlProxy)\n\n    fmt.Println("Server running on port: :", *port)\n    fmt.Println("Redirecting to:", *urlProxy)\n    fmt.Println("name: ", *name)\n    fmt.Println("pw", *password)\n}\n\n\nfunc main(){\n    // load our setup, :todo repalce this with env-values\n    getEnvValues()\n\n    // create our routes:\n    mux := http.NewServeMux()\n    mux.Handle("/login/", http.StripPrefix("/login/", http.FileServer(http.Dir("./public"))))\n    mux.HandleFunc("/api", handleLoginRequest)\n    mux.HandleFunc("/", handleRequestAndRedirect)\n    mux.HandleFunc("/logout", handleLogoutRequest)\n\n    err := http.ListenAndServe(":"+*port, mux)\n    if err != nil{\n        panic(err)\n    }\n}\n\n\n/*\n*   Handle Login/Logout\n*/\n\ntype LoginRequest struct{\n    Name        string `json:"name"`\n    Password    string `json:"password"`\n}\n\nfunc handleLoginRequest(rw http.ResponseWriter, req *http.Request){\n    writeBadRequest := func(){\n        rw.WriteHeader(http.StatusBadRequest)\n        rw.Write([]byte("400 - Bad Request"))\n    }\n\n    if req.Method != "POST"{\n        writeBadRequest()\n        return\n    } \n\n    var request LoginRequest\n    if err := json.NewDecoder(req.Body).Decode(&request); err != nil{\n        writeBadRequest()\n        return\n    }\n\n    if(request.Name =="vince" && request.Password=="123"){\n\n        // grant our cookie and then redirect to basepath\n        log.Println("login sucess - cookie granted")\n        addCookie(rw, "LoginToken", cookieToken, 2*time.Minute)\n\n        http.Redirect(rw, req, "/", http.StatusSeeOther)\n        //rw.Write([]byte("sending cookie over, have fun"))\n\n    } else {\n\n    fmt.Println(" :todo wrong pw")\n        log.Printf("name: %v pw: %v \\n",request.Name, request.Password)\n        writeBadRequest() \n    }\n    \n}\n\n// we use the cookie to store our credibility into, ;todo repalce with JWT\nfunc addCookie(rw http.ResponseWriter, name, value string, duration time.Duration){\n    expire := time.Now().Add(duration)\n    cookie := http.Cookie{\n        Name: name,\n        Value: value,\n        Expires: expire,\n        Path: "/",\n    }\n    http.SetCookie(rw, &cookie)\n}\n\n// logout just removes the cookie ( creating a  new one to overwrite old, setting negative time)\nfunc handleLogoutRequest(rw http.ResponseWriter, req *http.Request){\n    http.SetCookie(rw, &http.Cookie{\n        Name: "LoginToken",\n        Expires: time.Now().Add(-time.Hour),\n    })\n    rw.WriteHeader(http.StatusOK)\n    rw.Write([]byte("Logout Sucessful"))\n}\n\n\n/*\n*   redirect logic depending if were logged in or not\n*/\n\n// redirect requests to the appropriate url vs proxy\nfunc handleRequestAndRedirect(rw http.ResponseWriter, req *http.Request) {\n    validToken := false\n    cookie, err := req.Cookie("LoginToken")\n    if err != nil {\n        validToken = false\n    } else if cookie.Value==cookieToken{\n        validToken = true\n    }\n\n    if !validToken {\n        // not logged-in so we redirect to login page\n        http.Redirect(rw, req, "/login", http.StatusSeeOther)\n    } else {\n        // logged-in so we proxy forward to our proxy server\n        url := *urlProxy\n        log.Println("we serve proxy to:",url)\n\n        serveReverseProxy(url, rw, req)\n    }\n}\n\n\n/*\n*   the actual reverse proxy\n*/\nfunc serveReverseProxy(to string, rw http.ResponseWriter, req *http.Request){\n    url, err := url.Parse(to)\n    if err != nil{\n        panic(err)\n    }\n    \n    proxy := httputil.NewSingleHostReverseProxy(url)\n\n    // update headers to allow for ssl redirection\n    //req.URL.Host = url.Host\n    //req.URL.Scheme = url.Scheme\n    req.Header.Set("X-Forwarded-Host", req.Header.Get("Host"))\n    //req.Host = url.Host\n\n    proxy.ServeHTTP(rw, req)\n}\n')),(0,o.kt)("h1",{id:"minimal-html-and-js-for-a-login-page"},"minimal html and js for a login page"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"./public/index.html")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Login</title>\n    <style>\n        label {\n            display: block;\n            font: 0.9rem \'Fira Sans\', sans-serif;\n        }\n        input[type=\'submit\'],\n        label {\n            margin-top: 1rem;\n        }\n    </style>\n</head>\n<body>\n    <h1>Login:</h1>\n    <div id="app" class="app">\n        <div>\n            <label for="username">Username:</label>\n            <input id="username" type="text" id="username" name="username">\n        </div>\n        \n        <div>\n            <label for="pass">Password (8 chars minimum):</label>\n            <input id="password" type="password" id="pass" name="password" autofocus>\n        </div>\n        \n        <input id="submit" type="submit" value="Sign in">\n    </div>\n    <script defer type="text/javascript" src="./main.js"><\/script> \n</body>\n</html>\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"./public/main.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function App(){\n    console.log("js running")\n    let $name = document.querySelector("#username")\n    let $password = document.querySelector("#password")\n    let $submit = document.querySelector("#submit")\n    $submit.addEventListener("click", handleSubmit)\n\n    function handleSubmit(){\n        let name = $name.value\n        let pass = $password.value\n        loginRequest(name, pass)\n    }\n}\nApp()\n\n\nfunction loginRequest(name, pass){\n    fetch("/api",{\n                headers: {\n                \'Accept\': \'application/json\',\n                \'Content-Type\': \'application/json\'\n                },\n                method: "POST",\n                body: JSON.stringify({name: name, password: pass})\n            })\n    .then(res => {\n        if(!res.ok) throw Error(res.statusText)\n        console.log(res)\n        if (res.redirected) {\n            window.location.href = res.url;\n        }\n        return res\n    } )\n    .then(data => console.log(data))\n    .catch(function(res){ console.log(res) })\n}\n')))}d.isMDXComponent=!0}}]);