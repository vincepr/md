"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[4046],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),u=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(o.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,f=p["".concat(o,".").concat(m)]||p[m]||d[m]||s;return n?r.createElement(f,l(l({ref:t},c),{},{components:n})):r.createElement(f,l({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,l=new Array(s);l[0]=m;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[p]="string"==typeof e?e:a,l[1]=i;for(var u=2;u<s;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4511:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const s={},l="Crates projects, packages and modules in Rust",i={unversionedId:"rust/05crates",id:"rust/05crates",title:"Crates projects, packages and modules in Rust",description:"modules",source:"@site/docs/rust/05crates.md",sourceDirName:"rust",slug:"/rust/05crates",permalink:"/md/rust/05crates",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/rust/05crates.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Structures related to data in Rust",permalink:"/md/rust/04data"},next:{title:"Error Handling in Rust",permalink:"/md/rust/06errors"}},o={},u=[{value:"modules",id:"modules",level:2},{value:"paths",id:"paths",level:2},{value:"relative paths with super",id:"relative-paths-with-super",level:3},{value:"making structs and enums public.",id:"making-structs-and-enums-public",level:3},{value:"use keyword",id:"use-keyword",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"crates-projects-packages-and-modules-in-rust"},"Crates projects, packages and modules in Rust"),(0,a.kt)("h2",{id:"modules"},"modules"),(0,a.kt)("p",null,"start from the crate root. ",(0,a.kt)("inlineCode",{parentName:"p"},"src/lib.rs")," for a library- and ",(0,a.kt)("inlineCode",{parentName:"p"},"src/main.rs")," for a binary-crate."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// src/lib.rs\nmod our_restaurant {\n    pub mod cooking {\n        pub fn start_cooking() {}\n        fn plate_meal() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn payment() {}\n    }\n}\n")),(0,a.kt)("h2",{id:"paths"},"paths"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"absolute path is the full path starting from a crate root. it starts with the literal ",(0,a.kt)("inlineCode",{parentName:"li"},"crate")),(0,a.kt)("li",{parentName:"ul"},"relative path starts from the current module and uses ",(0,a.kt)("inlineCode",{parentName:"li"},"self"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"super"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"mod our_restaurant {\n    pub mod cooking {\n        pub fn start_cooking() {}\n    }\n}\n\npub fn dostuff(){\n    // absolute path\n    crate::our_restaurant::cooking::start_cooking();\n\n    // relative path\n    our_restaurant::cooking::start_cooking();\n}\n")),(0,a.kt)("h3",{id:"relative-paths-with-super"},"relative paths with super"),(0,a.kt)("p",null,"easy way to reference some parent function/struct. Useful if we think those components belong together and will be moved arround together if at all."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn basic_addition(){}\n\nmod modify {\n    fn fix_addition(){\n        fix();\n        super::basic_addition();\n    }\n    fn fix() {}\n}\n")),(0,a.kt)("h3",{id:"making-structs-and-enums-public"},"making structs and enums public."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"default for enums is public."),(0,a.kt)("li",{parentName:"ul"},"default for structs is private.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'mod restaurant {\n    pub struct Meal {\n        pub food: String,\n        price:  i32,\n    }\n    impl Meal {\n        pub fn make(f: &str) -> Meal {\n            Meal {\n                food: String::from(f),\n                price: 8,\n            }\n        }\n    }\n}\n\npub fn eat() {\n    let mut meal = restaurant::Meal::make("Muesli");\n    // we can still change our food because its public\n    meal.food = String("Toast a la Tuna");\n    println!("Ordering {}, please!", meal.food);\n    // println!("cant access {}!", meal.price);       // this will not compile because its private\n}\n')),(0,a.kt)("h2",{id:"use-keyword"},"use keyword"),(0,a.kt)("p",null,"to shorten inport paths."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'mod restaurant {\n    pub mod service{\n        pub fn clean_table(){}\n    }\n}\n\nuse crate::restaurant::service;\n\npub fn dostuff(){\n    restaurant::service::clean_table();\n    service::clean_table();             // same "target" as above\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"it is idiomatic to bring the service package in this case but not the function. ",(0,a.kt)("inlineCode",{parentName:"li"},"use crate::restaurant::service::clean_table")," That would make it difficoult to spot where ",(0,a.kt)("inlineCode",{parentName:"li"},"clean_table()")," is defined."),(0,a.kt)("li",{parentName:"ul"},"for enums and structs on the other hand it is idiomatic to bring them directly into scope:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::collections::HashMap;\n\nfn main(){\n    let mut map = HashMap::new();   // instead of collections::HashMap::new();\n    map.insert(1,2);\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"as keyword")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::Result as Res;\n\nfn function() => Res {}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"nesting imports")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// we can nest them like this:\nuse std::{fmt::Result, io }         \n\n// instead of 2 lines:\nuse std::io;\nuse std::io::Write;\n// we could also use self to reference itself:\nuse std::io::{self, Write}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the glob operator")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::collections::*;    // gets all items into scope\n")))}p.isMDXComponent=!0}}]);