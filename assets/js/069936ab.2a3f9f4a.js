"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[2901],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=l,g=c["".concat(s,".").concat(d)]||c[d]||m[d]||r;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5827:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=t(7462),l=(t(7294),t(3905));const r={},i="notes while learning golang",o={unversionedId:"go/intro",id:"go/intro",title:"notes while learning golang",description:"- Ctrl + Enter to autoformat whith gofmt Shift+Enter or go run . to quickly run code",source:"@site/docs/go/intro.md",sourceDirName:"go",slug:"/go/intro",permalink:"/md/go/intro",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/go/intro.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"wirtschaft_grundlagen",permalink:"/md/fiae/wirtschaft_grundlagen/"},next:{title:"webdev",permalink:"/md/category/webdev"}},s={},u=[{value:"1. Packages, variables and functions",id:"1-packages-variables-and-functions",level:2},{value:"variables, constants",id:"variables-constants",level:3},{value:"Type conversions",id:"type-conversions",level:3},{value:"import syntax",id:"import-syntax",level:3},{value:"functions",id:"functions",level:3},{value:"2. Flow control statments",id:"2-flow-control-statments",level:2},{value:"for loop",id:"for-loop",level:3},{value:"Range loop",id:"range-loop",level:4},{value:"conditional if statement",id:"conditional-if-statement",level:3},{value:"Switch",id:"switch",level:3},{value:"Defer",id:"defer",level:3},{value:"more types",id:"more-types",level:2},{value:"Pointers",id:"pointers",level:3},{value:"Structs",id:"structs",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Slices",id:"slices",level:3},{value:"Slice literals",id:"slice-literals",level:4},{value:"Slice length and capacity",id:"slice-length-and-capacity",level:4},{value:"Creating dynamic slices - make()",id:"creating-dynamic-slices---make",level:4},{value:"append to a slice <code>append(someSlice, 0)</code>",id:"append-to-a-slice-appendsomeslice-0",level:4},{value:"Maps",id:"maps",level:3},{value:"mutating maps",id:"mutating-maps",level:4},{value:"Function closures",id:"function-closures",level:3}],p={toc:u};function c(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"notes-while-learning-golang"},"notes while learning golang"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Ctrl + Enter to autoformat whith gofmt Shift+Enter or ",(0,l.kt)("inlineCode",{parentName:"li"},"go run .")," to quickly run code")),(0,l.kt)("h2",{id:"1-packages-variables-and-functions"},"1. Packages, variables and functions"),(0,l.kt)("h3",{id:"variables-constants"},"variables, constants"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var x, y, z bool\nconst Num1, Num2 int = 8 , 99\n// in functions we can use :=\nfunc main {\n    itsaInt := 1\n    itsaFloat := 1.0\n    mix1, mix2, mix3 := "hello", 1, true\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"basic types"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bool")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"string")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"int  int8  int16  int32  int64")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"uint uint8 uint16 uint32 uint64 uintptr")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"byte // alias for uint8")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rune // alias for int32 // represents a Unicode code point")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"float32 float64")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"complex64 complex128")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"if declared wihtout explicit initial value, they are given their zero value: ",(0,l.kt)("inlineCode",{parentName:"p"},'false, 0 and emptystring: ""')))),(0,l.kt)("h3",{id:"type-conversions"},"Type conversions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"var i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\ni := 42\nf := float64(i)\nu := uint(f)\n")),(0,l.kt)("h3",{id:"import-syntax"},"import syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "math"\n    "math/rand"\n)\nfunc main(){\n    var rng float64 = float64( rand.Intn(10) )\n    fmt.Println("Random numer is: ", rng, "\\n sqrt of it is: ", math.Sqrt(rng) )\n}\n')),(0,l.kt)("h3",{id:"functions"},"functions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func swap(x, y string) (string, string) {\n    return y, x\n}\n\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n")),(0,l.kt)("h2",{id:"2-flow-control-statments"},"2. Flow control statments"),(0,l.kt)("h3",{id:"for-loop"},"for loop"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"there is only one loop, the for-loop ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'sum := 0\nfor i := 0; i < 10; i++ {\n    sum += i\n}\n// "while" loop\nsum := 1\nfor sum < 1000 {\n    sum += sum\n}\n')),(0,l.kt)("h4",{id:"range-loop"},"Range loop"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the range form of the for loop iterates over a slice or map"),(0,l.kt)("li",{parentName:"ul"},"when ranging over a slice 2 values are returned each iteration, first index, second a ",(0,l.kt)("strong",{parentName:"li"},"copy")," of the element")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\nfor idx, value := range pow {\n    fmt.Printf("2**%d = %d\\n", idx, value)\n}\n// ->   2**0 = 1\n// ->   2**1 = 2\n// ...\n// ->   2**6 = 64\n// ->   2**7 = 128\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"you can skip the index by assigning to _. you can just omit the 2nd variable if you only need the index")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"for _,value : range pow{\n    //....\n}\n")),(0,l.kt)("h3",{id:"conditional-if-statement"},"conditional if statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v < lim {\n        return v\n    } else {\n        return lim   \n    }\n}\n")),(0,l.kt)("h3",{id:"switch"},"Switch"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'    t := 10\n    switch {\n    case t > 5:\n        fmt.Println("is bigger 5")\n    case t == 10;\n        fmt.Println("is equal to 10")\n    default:\n        fmt.Println("is someting else")\n    }\n')),(0,l.kt)("h3",{id:"defer"},"Defer"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A defer statement defers the execution of a function until the surrounding function returns.            "),(0,l.kt)("li",{parentName:"ul"},"Defer function calls are pushed onto a stack. And executed in last-in-fost-out order.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    count := 10\n    defer fmt.Println("world", count)\n    count += 5\n    fmt.Println("hello", count)\n}\n// hello 15\n// world 10\nfunc countdown(){\n    fmt.Println("counting")\n\n    for i := 0; i < 10; i++ {\n        defer fmt.Println(i)\n    }\n\n    fmt.Println("done")\n}\n// counting\n// done\n// 9\n// 8 \n// ...\n// 1\n// 0\n')),(0,l.kt)("h2",{id:"more-types"},"more types"),(0,l.kt)("h3",{id:"pointers"},"Pointers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*T")," is a pointer to a T value. Its zer value is ",(0,l.kt)("inlineCode",{parentName:"li"},"nil")),(0,l.kt)("li",{parentName:"ul"},"pointers in go have no pointer arithmetic by default. ",(0,l.kt)("inlineCode",{parentName:"li"},'import "unsafe"')," if those are needed.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n    i, j := 42, 2700\n    p := &i         // point to i\n    fmt.Println(*p) // read i through the pointer   -> print: 42\n    *p = 21         // set i through the pointer    -> i = 21\n    fmt.Println(i)  // see the new value of i       -> print: 21\n\n    p = &j         // point to j\n    *p = *p / 2   // divide j through the pointer   -> j = 1350\n    fmt.Println(j) // see the new value of j        -> print: 1350\n}\n")),(0,l.kt)("h3",{id:"structs"},"Structs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'base := Coordinates{10, 22, 0}\nfmt.Println("coordinates are: ", base)\nbase.Height = -5\nfmt.Println("Height is: ", base.Height)\n// short form of accessing on pointers (*p).X becmes just p.X\npointer1 := &base\npointer1.X = 1e9\nfmt.Println(base)\n')),(0,l.kt)("h3",{id:"arrays"},"Arrays"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"have fixed size, can not be resized.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\na[0] = "Hello"\na[1] = "World"\nprimes := [6]int{2, 3, 5, 7, 11, 13}\n')),(0,l.kt)("h3",{id:"slices"},"Slices"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dynamically sized"),(0,l.kt)("li",{parentName:"ul"},"are references to the underlying array -> changes to the slice -> change the array"),(0,l.kt)("li",{parentName:"ul"},"slices can contain any type, including other slices")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"primes := [6]int{2, 3, 5, 7, 11, 13}\nvar slice []int = primes[1:4]   // [inclusive:exclusive]\nfmt.Println(slice)              //-> {3,5,7}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when slicing you can omit the bounds:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{2, 3, 5, 7, 11, 13}\nfmt.Println(s[:2])              // -> [2 3]\nfmt.Println(s[1:])              // -> [3 5 7 11 13]\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the zero value of a slice is ",(0,l.kt)("inlineCode",{parentName:"li"},"nil"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var s []int\nfmt.Println(s, len(s), cap(s))  // -> [] 0 0\nif s == nil {\n    fmt.Println("is nil!")      // -> is nil!\n}\n')),(0,l.kt)("h4",{id:"slice-literals"},"Slice literals"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"is like any array but without the length"),(0,l.kt)("li",{parentName:"ul"},"basically creates the same array, then builds a slice that references it")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"r := []bool{true, false, true, true, false, true}\ns := []struct {\n    i int\n    b bool\n}{\n    {2, true},\n    {3, false},\n    {5, true},\n    {7, true},\n    {11, false},\n    {99, true},\n}\nfmt.Println(r , s)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("h4",{id:"slice-length-and-capacity"},"Slice length and capacity"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"len()")," is the number of element it contains"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cap()")," is the number of elements in the underlying array, counting from the first element in the slice.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    s := []int{2, 3, 5, 7, 11, 13}\n    printSlice(s)\n    // -> len=6 cap=6 [2 3 5 7 11 13]\n\n    // Slice the slice to give it zero length.\n    s = s[:0]\n    printSlice(s)\n    // -> len=0 cap=6 []\n    \n    // Extend its length.\n    s = s[:4]\n    printSlice(s)\n    // -> len=4 cap=6 [2 3 5 7]\n\n    // Drop its first two values.\n    s = s[2:]\n    printSlice(s)\n    // -> len=2 cap=4 [5 7]\n\n    // Drop another value from front but extend it +2 at end\n    s = s[1:4]\n    printSlice(s)\n    // -> len=3 cap=3 [7 11 13]\n    // !cant extent beyond this since underlaying array maxes out here \n}\n\nfunc printSlice(s []int) {\n    fmt.Printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n')),(0,l.kt)("h4",{id:"creating-dynamic-slices---make"},"Creating dynamic slices - make()"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the make function allocates a zerod array and returns a slice that refers to that array."),(0,l.kt)("li",{parentName:"ul"},"this is how we create dynamically-sized arrays.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"a := make([]int, 5)         // len(a)=5\nb := make([]int, 0, 5)      // len(b)=0, cap(b)=5\nb = b[:cap(b)]              // len(b)=5, cap(b)=5\nb = b[1:]                   // len(b)=4, cap(b)=4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"example:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    a := make([]int, 5)\n    printSlice("a", a)      // -> a len=5 cap=5 [0 0 0 0 0]\n\n    b := make([]int, 0, 5)\n    printSlice("b", b)      // -> b len=0 cap=5 []\n\n    c := b[:2]\n    printSlice("c", c)      // -> c len=2 cap=5 [0 0]\n\n    d := c[2:5]\n    printSlice("d", d)      // -> d len=3 cap=3 [0 0 0]\n}\n\nfunc printSlice(s string, x []int) {\n    fmt.Printf("%s len=%d cap=%d %v\\n",\n        s, len(x), cap(x), x)\n}\n\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"another example for some pseudo tic tac toe board")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    // Create a tic-tac-toe board.\n    board := [][]string{\n        []string{"_", "_", "_"},\n        []string{"_", "_", "_"},\n        []string{"_", "_", "_"},\n    }\n\n    // The players take turns.\n    board[0][0] = "X"\n    board[2][2] = "O"\n    board[1][2] = "X"\n    board[1][0] = "O"\n    board[0][2] = "X"\n\n    for i := 0; i < len(board); i++ {\n        fmt.Printf("%s\\n", strings.Join(board[i], " "))\n    }\n}\n')),(0,l.kt)("h4",{id:"append-to-a-slice-appendsomeslice-0"},"append to a slice ",(0,l.kt)("inlineCode",{parentName:"h4"},"append(someSlice, 0)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the backing array of s is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"var s []int\ns = append(s, 0)            // append works on nil slices.\ns = append(s, 1)            // The slice grows as needed.\ns = append(s, 2, 3, 4)      // We can add more than one \n")),(0,l.kt)("h3",{id:"maps"},"Maps"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The zero value of a map is nil. A nil map has no keys, nor can keys be added.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m map[string]Vertex\nm = make(map[string]Vertex)\nm["Bell Labs"] = Vertex{\n    40.68433, -74.39967,\n}\nfmt.Println(m["Bell Labs"])\n\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"or as literal:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m = map[string]Vertex{\n    "Bell Labs": Vertex{\n        40.68433, -74.39967,\n    },\n    "Google": Vertex{\n        37.42202, -122.08408,\n    },\n}\nfmt.Println(m)\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m = map[string]Vertex{\n    "Bell Labs": {40.68433, -74.39967},\n    "Google":    {37.42202, -122.08408},\n}\n\nfmt.Println(m)\n')),(0,l.kt)("h4",{id:"mutating-maps"},"mutating maps"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'    m := make(map[string]int)\n    m["Answer"] = 42                            // insert or update an element in map m\n    fmt.Println("The value:", m["Answer"])      // retrieve an element\n    delete(m, "Answer")                         // delete an element\n    fmt.Println("The value:", m["Answer"])      // -> The value: 0  <- !! notice the zero value here !! \n    answer, isPresent := m["Answer"]\n    fmt.Println(answer, isPresent)              // -> 0 false\n')),(0,l.kt)("h3",{id:"function-closures"},"Function closures"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For example, the adder function returns a closure. Each closure is bound to its own sum variable."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    pos, neg := adder(), adder()\n    for i := 0; i < 10; i++ {\n        fmt.Println(\n            pos(i),\n            neg(-2*i),\n        )\n    }\n}\n")))}c.isMDXComponent=!0}}]);