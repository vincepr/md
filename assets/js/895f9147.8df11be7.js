"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[4763],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,f=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3052:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={},i="part4 - CommandsService",l={unversionedId:"csharp/examples/Microservices/part4-commandsService",id:"csharp/examples/Microservices/part4-commandsService",title:"part4 - CommandsService",description:"Setup",source:"@site/docs/csharp/examples/Microservices/part4-commandsService.md",sourceDirName:"csharp/examples/Microservices",slug:"/csharp/examples/Microservices/part4-commandsService",permalink:"/md/csharp/examples/Microservices/part4-commandsService",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/csharp/examples/Microservices/part4-commandsService.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"part3 - Kubernetes - aka K8S",permalink:"/md/csharp/examples/Microservices/part3-kubernetes"},next:{title:"part5 - NGINX Api-Gateway",permalink:"/md/csharp/examples/Microservices/part5-NGINX-Gateway"}},s={},p=[{value:"Setup",id:"setup",level:2},{value:"in CommandsService project(this project)",id:"in-commandsservice-projectthis-project",level:2},{value:"in PlatformService project(the other project)",id:"in-platformservice-projectthe-other-project",level:3},{value:"getting Commands Services ready for Kubernetes",id:"getting-commands-services-ready-for-kubernetes",level:2},{value:"starting Kubernetes up",id:"starting-kubernetes-up",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"part4---commandsservice"},"part4 - CommandsService"),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"dotnet new webapi -n CommandsService\n\ndotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection\ndotnet add package Microsoft.EntityFrameworkCore\ndotnet add package Microsoft.EntityFrameworkCore.Design\n\ndotnet add package Microsoft.EntityFrameworkCore.InMemory\n")),(0,a.kt)("h2",{id:"in-commandsservice-projectthis-project"},"in CommandsService project(this project)"),(0,a.kt)("p",null,"an Endpoint the other Service can post to, to notify this service when he created a new platform. (syncrhous tight coupling)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpPost]\npublic ActionResult TestInboundConnection() {\n    Console.WriteLine("--\x3e Inbound POST # Command Service");\n    return Ok("Inbound test of from Platforms Controller");\n}\n')),(0,a.kt)("h3",{id:"in-platformservice-projectthe-other-project"},"in PlatformService project(the other project)"),(0,a.kt)("p",null,"We modify the other endpoint to pass down an notification everytime it creates a new platform."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpPost]\npublic async Task<ActionResult<PlatformReadDto>> CreatePlatform(PlatformCreateDto dto)\n{\n    var newPlatform = _mapper.Map<Platform>(dto);\n    _repository.CreatePlatform(newPlatform);\n    if (_repository.SaveChanges() == false) return StatusCode(500);\n        \n    var platformReadDto = _mapper.Map<PlatformReadDto>(newPlatform);\n\n    try {\n        await _commandDataClient.SendPlatformTocommand(platformReadDto);\n    } catch (Exception e) {\n        Console.WriteLine("$--\x3e Could not send synchronousl. " + e.Message);\n    }\n\n    return CreatedAtRoute(\n        nameof(GetPlatformById),            // provides a link to the /api/get/{newId}\n        new { Id = platformReadDto.Id },    // the id of our newly created obj\n        platformReadDto);                   // and we also return the dtoObject directly\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"we also change launchSetting.json to use different ports for each Service"),(0,a.kt)("li",{parentName:"ul"},"and statically let our PlatformService know where to send data to: ",(0,a.kt)("inlineCode",{parentName:"li"},"appsettings.Development.json"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Logging": {\n    "LogLevel": {\n      "Default": "Information",\n      "Microsoft.AspNetCore": "Warning"\n    }\n  },\n  "CommandService": "http://localhost:6000/api/c/platforms/"\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"sending a post request happens in ",(0,a.kt)("inlineCode",{parentName:"li"},"SyncDataService/Http/HttpCommandDataClient.cs"),", that we dependencyinject with an interface to use in our Endpoint above.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace PlatformService.SyncDataService.Http {\n    public class HttpCommandDataClient : ICommandDataClient {\n        private readonly HttpClient _httpClient;\n        private readonly IConfiguration _configuration;\n\n        // IConfiguration can be injected basically everywhere.\n        // - here we use it to read out from our appsettings.json\n        public HttpCommandDataClient(HttpClient httpClient, IConfiguration configuration) {\n            _httpClient = httpClient;\n            _configuration = configuration;\n\n        }\n\n        public async Task SendPlatformTocommand(PlatformReadDto newPlat) {\n            var httpBody = new StringContent(\n                JsonSerializer.Serialize(newPlat),\n                Encoding.UTF8,\n                "application/json");\n            var resp = await _httpClient.PostAsync($"{_configuration["CommandService"]}", httpBody);\n            if (resp.IsSuccessStatusCode) \n                Console.WriteLine("--\x3e Sync POST to CommandService was OK.");\n            else\n                Console.WriteLine("--\x3e Sync POST to CommandService was NOT ok!");\n        }\n    }\n}\n')),(0,a.kt)("h2",{id:"getting-commands-services-ready-for-kubernetes"},"getting Commands Services ready for Kubernetes"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Create the Dockerfile")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-Dockerfile"},'FROM mcr.microsoft.com/dotnet/sdk:7.0 as build-envFROM\nWORKDIR /app\n\nCOPY *.csproj ./\nRUN dotnet restore\n\nCOPY . ./\nRUN dotnet publish -c Release -o out\n\nFROM mcr.microsoft.com/dotnet/aspnet:7.0\nWORKDIR /app\nCOPY --from=build-envFROM /app/out .\nENTRYPOINT [ "dotnet", "CommandsService.dll" ]\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"and push it to Dockerhub")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"docker build -t vincepr/commandservice .\ndocker push vincepr/commandservice\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"next we add ",(0,a.kt)("inlineCode",{parentName:"li"},"/K8S/commands-depl.yaml"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"basically the same deployment as for the PlatformService but with changed names"),(0,a.kt)("li",{parentName:"ul"},"next we add the ",(0,a.kt)("strong",{parentName:"li"},"ClusterIpService")," to both delpoyments (everything above the ",(0,a.kt)("inlineCode",{parentName:"li"},"---"),")",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"these ClusterIPServices enable direct communication inside our Kubernetes Cluster")))))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: commands-depl\nspec:\n  # replicas are basically horizontal scaling (ex multiple api containers that run at the same time etc...)\n  replicas: 1\n  # selector and template are defining the template were creating\n  selector:\n    matchLabels:\n      app: commandservice\n  template:\n    metadata:\n      labels:\n        app: commandservice\n    spec:\n      containers:\n        ## we use our previously created docker containers here\n        - name: commandservice\n          image: vincepr/commandservice:latest\n---\n# we could put this in a separate file, --- separates this as a 'new' one\n# We add a new ClusterIpService to our Deployment\napiVersion: v1\nkind: Service\nmetadata:\n  name: commands-clusterip-srv\nspec:\n  type: ClusterIP\n  selector:\n    app: commandservice\n  ports:\n    - name: commandservice\n      protocol: TCP\n      port: 80\n      targetPort: 80\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"since PlatformService needs to know the exact location and port of the endpoint to send the POST request to CommandsService to, we have to add a ",(0,a.kt)("inlineCode",{parentName:"li"},"appsettings.Production.json"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "CommandService": "http://commands-clusterip-srv:80/api/c/platforms/"\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"now we have to rebuild the platformservice docker container with the new appsettings included:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"docker build -t vincepr/platformservice ./PlatformService\ndocker push vincepr/platformservice\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE"),": it would be better to extract those settings outside of the docker image itself and work with for examples env paramaters. But this is not scope of this tutorial."),(0,a.kt)("h2",{id:"starting-kubernetes-up"},"starting Kubernetes up"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"first we check previous state:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"kubectl get deployments\n# NAME             READY   UP-TO-DATE   AVAILABLE   AGE\n# platforms-depl   1/1     1            1           3d15h\n\nkubectl get pods\n# NAME                              READY   STATUS    RESTARTS       AGE\n# platforms-depl-85677fb59d-7bgf7   1/1     Running   2 (114m ago)   3d15h\n\nkubectl get services\n# NAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\n# kubernetes              ClusterIP   10.96.0.1      <none>        443/TCP        4d15h\n# platformnpservice-srv   NodePort    10.103.51.73   <none>        80:30085/TCP   3d15h\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"we apply our changed file:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"NOTICE")," how the new platformsclusterip-srv has started up."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"BUT")," what kubernetes did not do, was go get the latest dockerfile from dockerhub (the one including our added appsettings.Development.json)")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"kubectl apply -f ./K8S/platforms-depl.yaml\n# deployment.apps/platforms-depl unchanged\n# service/platforms-clusterip-srv created\n\nkubectl get services\n# NAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\n# kubernetes                ClusterIP   10.96.0.1       <none>        443/TCP        4d15h        \n# platformnpservice-srv     NodePort    10.103.51.73    <none>        80:30085/TCP   3d15h        \n# platforms-clusterip-srv   ClusterIP   10.97.239.139   <none>        80/TCP         46s\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"so we force kubernetes to update to the latest version:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"kubectl rollout restart deployment platforms-depl\n")),(0,a.kt)("p",null,"When we check the logs for that freshly started Container:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"we can see that it got the right endpoint ",(0,a.kt)("inlineCode",{parentName:"li"}," http://commands-clusterip-srv:80/]"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"2023-10-14 13:36:01 info: Microsoft.EntityFrameworkCore.Update[30100]\n2023-10-14 13:36:01       Saved 3 entities to in-memory store.\n2023-10-14 13:36:01 ---\x3e Seeding Data with some made up Data\n2023-10-14 13:36:01 --\x3e config[CommandService] endpoint: http://platforms-clusterip-srv:80/api/c/platforms/\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"so now we finally add our 2nd service to our Cluster",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"now we have 2 Services with one ClusterIp each running")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"kubectl apply -f ./K8S/commands-depl.yaml\n\nNAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\n# commands-clusterip-srv    ClusterIP   10.105.102.58   <none>        80/TCP         18s\n# kubernetes                ClusterIP   10.96.0.1       <none>        443/TCP        4d15h        \n# platformnpservice-srv     NodePort    10.103.51.73    <none>        80:30085/TCP   3d15h        \n# platforms-clusterip-srv   ClusterIP   10.97.239.139   <none>        80/TCP         10m\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"now we POST to our exposed enpoing ",(0,a.kt)("inlineCode",{parentName:"li"},"http://localhost:30085/api/platforms/")),(0,a.kt)("li",{parentName:"ul"},"Our platformervice Log reveals it successfully made it's postrequest")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"2023-10-14 15:14:08 info: Microsoft.EntityFrameworkCore.Update[30100]\n2023-10-14 15:14:08       Saved 1 entities to in-memory store.\n2023-10-14 15:14:08 info: System.Net.Http.HttpClient.ICommandDataClient.LogicalHandler[100]\n2023-10-14 15:14:08       Start processing HTTP request POST http://commands-clusterip-srv/api/c/platforms/\n2023-10-14 15:14:08 info: System.Net.Http.HttpClient.ICommandDataClient.ClientHandler[100]\n2023-10-14 15:14:08       Sending HTTP request POST http://commands-clusterip-srv/api/c/platforms/\n2023-10-14 15:14:08 info: System.Net.Http.HttpClient.ICommandDataClient.ClientHandler[101]\n2023-10-14 15:14:08       Received HTTP response headers after 106.5811ms - 200\n2023-10-14 15:14:08 info: System.Net.Http.HttpClient.ICommandDataClient.LogicalHandler[101]\n2023-10-14 15:14:08       End processing HTTP request after 113.9815ms - 200\n2023-10-14 15:14:08 --\x3e Sync POST to CommandService was OK.\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"And our commandservice recieved the inbound request:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"2023-10-14 15:14:08 warn: Microsoft.AspNetCore.HttpsPolicy.HttpsRedirectionMiddleware[3]\n2023-10-14 15:14:08       Failed to determine the https port for redirect.\n2023-10-14 15:14:08 --\x3e Inbound POST # Command Service\n")))}m.isMDXComponent=!0}}]);