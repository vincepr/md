"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[2901],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(t),d=l,f=p["".concat(s,".").concat(d)]||p[d]||m[d]||r;return t?a.createElement(f,i(i({ref:n},c),{},{components:t})):a.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[p]="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5827:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=t(7462),l=(t(7294),t(3905));const r={},i="notes while learning golang",o={unversionedId:"go/intro",id:"go/intro",title:"notes while learning golang",description:"- Ctrl + Enter to autoformat whith gofmt Shift+Enter or go run . to quickly run code",source:"@site/docs/go/intro.md",sourceDirName:"go",slug:"/go/intro",permalink:"/md/go/intro",draft:!1,editUrl:"https://github.com/vincepr/md/blob/main/docs/go/intro.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Exercises",permalink:"/md/go/exercises"},next:{title:"webdev",permalink:"/md/category/webdev"}},s={},u=[{value:"1. Packages, variables and functions",id:"1-packages-variables-and-functions",level:2},{value:"variables, constants",id:"variables-constants",level:3},{value:"Type conversions",id:"type-conversions",level:3},{value:"import syntax",id:"import-syntax",level:3},{value:"functions",id:"functions",level:3},{value:"2. Flow control statments",id:"2-flow-control-statments",level:2},{value:"for loop",id:"for-loop",level:3},{value:"Range loop",id:"range-loop",level:4},{value:"conditional if statement",id:"conditional-if-statement",level:3},{value:"Switch",id:"switch",level:3},{value:"Defer",id:"defer",level:3},{value:"2. more types",id:"2-more-types",level:2},{value:"Pointers",id:"pointers",level:3},{value:"Structs",id:"structs",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Slices",id:"slices",level:3},{value:"Slice literals",id:"slice-literals",level:4},{value:"Slice length and capacity",id:"slice-length-and-capacity",level:4},{value:"Creating dynamic slices - make()",id:"creating-dynamic-slices---make",level:4},{value:"append to a slice <code>append(someSlice, 0)</code>",id:"append-to-a-slice-appendsomeslice-0",level:4},{value:"Maps",id:"maps",level:3},{value:"mutating maps",id:"mutating-maps",level:4},{value:"Function closures",id:"function-closures",level:3},{value:"3. Methods and interfaces",id:"3-methods-and-interfaces",level:2},{value:"define methods on types",id:"define-methods-on-types",level:3},{value:"Pointer receivers",id:"pointer-receivers",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"how to handle nil - and avoid &quot;null pointer&quot; exceptions in go",id:"how-to-handle-nil---and-avoid-null-pointer-exceptions-in-go",level:4},{value:"empty interface",id:"empty-interface",level:4},{value:"Type assertions",id:"type-assertions",level:3},{value:"Type switches",id:"type-switches",level:3},{value:"Stringers",id:"stringers",level:3},{value:"Example",id:"example",level:4},{value:"Errors",id:"errors",level:3},{value:"Readers - Data Sreams",id:"readers---data-sreams",level:3},{value:"The following example creates a strings.Reader and consumes its output 8 bytes at a time:",id:"the-following-example-creates-a-stringsreader-and-consumes-its-output-8-bytes-at-a-time",level:4},{value:"Wrapping a reader in another reader",id:"wrapping-a-reader-in-another-reader",level:4},{value:"Images",id:"images",level:3},{value:"4. Generics",id:"4-generics",level:2},{value:"Generic functioins - unsing Type parameters",id:"generic-functioins---unsing-type-parameters",level:3},{value:"Generic types",id:"generic-types",level:3},{value:"5. Concurrency",id:"5-concurrency",level:2},{value:"Goroutines",id:"goroutines",level:3},{value:"Channels",id:"channels",level:3},{value:"Buffered Channels",id:"buffered-channels",level:4},{value:"Close Channels",id:"close-channels",level:4},{value:"Select",id:"select",level:4},{value:"sync.Mutex",id:"syncmutex",level:3}],c={toc:u};function p(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"notes-while-learning-golang"},"notes while learning golang"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Ctrl + Enter to autoformat whith gofmt Shift+Enter or ",(0,l.kt)("inlineCode",{parentName:"li"},"go run .")," to quickly run code")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"1-packages-variables-and-functions"},"1. Packages, variables and functions"),(0,l.kt)("h3",{id:"variables-constants"},"variables, constants"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var x, y, z bool\nconst Num1, Num2 int = 8 , 99\n// in functions we can use :=\nfunc main {\n    itsaInt := 1\n    itsaFloat := 1.0\n    mix1, mix2, mix3 := "hello", 1, true\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"basic types"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"bool")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"string")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"int  int8  int16  int32  int64")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"uint uint8 uint16 uint32 uint64 uintptr")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"byte // alias for uint8")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"rune // alias for int32 // represents a Unicode code point")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"float32 float64")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"complex64 complex128")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"if declared wihtout explicit initial value, they are given their zero value: ",(0,l.kt)("inlineCode",{parentName:"p"},'false, 0 and emptystring: ""')))),(0,l.kt)("h3",{id:"type-conversions"},"Type conversions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"var i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\ni := 42\nf := float64(i)\nu := uint(f)\n")),(0,l.kt)("h3",{id:"import-syntax"},"import syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "math"\n    "math/rand"\n)\nfunc main(){\n    var rng float64 = float64( rand.Intn(10) )\n    fmt.Println("Random numer is: ", rng, "\\n sqrt of it is: ", math.Sqrt(rng) )\n}\n')),(0,l.kt)("h3",{id:"functions"},"functions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func swap(x, y string) (string, string) {\n    return y, x\n}\n\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n")),(0,l.kt)("h2",{id:"2-flow-control-statments"},"2. Flow control statments"),(0,l.kt)("h3",{id:"for-loop"},"for loop"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"there is only one loop, the for-loop ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'sum := 0\nfor i := 0; i < 10; i++ {\n    sum += i\n}\n// "while" loop\nsum := 1\nfor sum < 1000 {\n    sum += sum\n}\n')),(0,l.kt)("h4",{id:"range-loop"},"Range loop"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the range form of the for loop iterates over a slice or map"),(0,l.kt)("li",{parentName:"ul"},"when ranging over a slice 2 values are returned each iteration, first index, second a ",(0,l.kt)("strong",{parentName:"li"},"copy")," of the element")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\nfor idx, value := range pow {\n    fmt.Printf("2**%d = %d\\n", idx, value)\n}\n// ->   2**0 = 1\n// ->   2**1 = 2\n// ...\n// ->   2**6 = 64\n// ->   2**7 = 128\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"you can skip the index by assigning to _. you can just omit the 2nd variable if you only need the index")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"for _,value : range pow{\n    //....\n}\n")),(0,l.kt)("h3",{id:"conditional-if-statement"},"conditional if statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v < lim {\n        return v\n    } else {\n        return lim   \n    }\n}\n")),(0,l.kt)("h3",{id:"switch"},"Switch"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'    t := 10\n    switch {\n    case t > 5:\n        fmt.Println("is bigger 5")\n    case t == 10;\n        fmt.Println("is equal to 10")\n    default:\n        fmt.Println("is someting else")\n    }\n')),(0,l.kt)("h3",{id:"defer"},"Defer"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A defer statement defers the execution of a function until the surrounding function returns.            "),(0,l.kt)("li",{parentName:"ul"},"Defer function calls are pushed onto a stack. And executed in last-in-fost-out order.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    count := 10\n    defer fmt.Println("world", count)\n    count += 5\n    fmt.Println("hello", count)\n}\n// hello 15\n// world 10\nfunc countdown(){\n    fmt.Println("counting")\n\n    for i := 0; i < 10; i++ {\n        defer fmt.Println(i)\n    }\n\n    fmt.Println("done")\n}\n// counting\n// done\n// 9\n// 8 \n// ...\n// 1\n// 0\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"2-more-types"},"2. more types"),(0,l.kt)("h3",{id:"pointers"},"Pointers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*T")," is a pointer to a T value. Its zer value is ",(0,l.kt)("inlineCode",{parentName:"li"},"nil")),(0,l.kt)("li",{parentName:"ul"},"pointers in go have no pointer arithmetic by default. ",(0,l.kt)("inlineCode",{parentName:"li"},'import "unsafe"')," if those are needed.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n    i, j := 42, 2700\n    p := &i         // point to i\n    fmt.Println(*p) // read i through the pointer   -> print: 42\n    *p = 21         // set i through the pointer    -> i = 21\n    fmt.Println(i)  // see the new value of i       -> print: 21\n\n    p = &j          // point to j\n    *p = *p / 2     // divide j through the pointer -> j = 1350\n    fmt.Println(j)  // see the new value of j       -> print: 1350\n}\n")),(0,l.kt)("h3",{id:"structs"},"Structs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'base := Coordinates{10, 22, 0}\nfmt.Println("coordinates are: ", base)\nbase.Height = -5\nfmt.Println("Height is: ", base.Height)\n// short form of accessing on pointers (*p).X becmes just p.X\npointer1 := &base\npointer1.X = 1e9\nfmt.Println(base)\n')),(0,l.kt)("h3",{id:"arrays"},"Arrays"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"have fixed size, can not be resized.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\na[0] = "Hello"\na[1] = "World"\nprimes := [6]int{2, 3, 5, 7, 11, 13}\n')),(0,l.kt)("h3",{id:"slices"},"Slices"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dynamically sized"),(0,l.kt)("li",{parentName:"ul"},"are references to the underlying array -> changes to the slice -> change the array"),(0,l.kt)("li",{parentName:"ul"},"slices can contain any type, including other slices")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"primes := [6]int{2, 3, 5, 7, 11, 13}\nvar slice []int = primes[1:4]   // [inclusive:exclusive]\nfmt.Println(slice)              //-> {3,5,7}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when slicing you can omit the bounds:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{2, 3, 5, 7, 11, 13}\nfmt.Println(s[:2])              // -> [2 3]\nfmt.Println(s[1:])              // -> [3 5 7 11 13]\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the zero value of a slice is ",(0,l.kt)("inlineCode",{parentName:"li"},"nil"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var s []int\nfmt.Println(s, len(s), cap(s))  // -> [] 0 0\nif s == nil {\n    fmt.Println("is nil!")      // -> is nil!\n}\n')),(0,l.kt)("h4",{id:"slice-literals"},"Slice literals"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"is like any array but without the length"),(0,l.kt)("li",{parentName:"ul"},"basically creates the same array, then builds a slice that references it")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"r := []bool{true, false, true, true, false, true}\ns := []struct {\n    i int\n    b bool\n}{\n    {2, true},\n    {3, false},\n    {5, true},\n    {7, true},\n    {11, false},\n    {99, true},\n}\nfmt.Println(r , s)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var a [2]string\n    a[0] = "Hello"\n    a[1] = "World"\n')),(0,l.kt)("h4",{id:"slice-length-and-capacity"},"Slice length and capacity"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"len()")," is the number of element it contains"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cap()")," is the number of elements in the underlying array, counting from the first element in the slice.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    s := []int{2, 3, 5, 7, 11, 13}\n    printSlice(s)\n    // -> len=6 cap=6 [2 3 5 7 11 13]\n\n    // Slice the slice to give it zero length.\n    s = s[:0]\n    printSlice(s)\n    // -> len=0 cap=6 []\n    \n    // Extend its length.\n    s = s[:4]\n    printSlice(s)\n    // -> len=4 cap=6 [2 3 5 7]\n\n    // Drop its first two values.\n    s = s[2:]\n    printSlice(s)\n    // -> len=2 cap=4 [5 7]\n\n    // Drop another value from front but extend it +2 at end\n    s = s[1:4]\n    printSlice(s)\n    // -> len=3 cap=3 [7 11 13]\n    // !cant extent beyond this since underlaying array maxes out here \n}\n\nfunc printSlice(s []int) {\n    fmt.Printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n')),(0,l.kt)("h4",{id:"creating-dynamic-slices---make"},"Creating dynamic slices - make()"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the make function allocates a zerod array and returns a slice that refers to that array."),(0,l.kt)("li",{parentName:"ul"},"this is how we create dynamically-sized arrays.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"a := make([]int, 5)         // len(a)=5\nb := make([]int, 0, 5)      // len(b)=0, cap(b)=5\nb = b[:cap(b)]              // len(b)=5, cap(b)=5\nb = b[1:]                   // len(b)=4, cap(b)=4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"example:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    a := make([]int, 5)\n    printSlice("a", a)      // -> a len=5 cap=5 [0 0 0 0 0]\n\n    b := make([]int, 0, 5)\n    printSlice("b", b)      // -> b len=0 cap=5 []\n\n    c := b[:2]\n    printSlice("c", c)      // -> c len=2 cap=5 [0 0]\n\n    d := c[2:5]\n    printSlice("d", d)      // -> d len=3 cap=3 [0 0 0]\n}\n\nfunc printSlice(s string, x []int) {\n    fmt.Printf("%s len=%d cap=%d %v\\n",\n        s, len(x), cap(x), x)\n}\n\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"another example for some pseudo tic tac toe board")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    // Create a tic-tac-toe board.\n    board := [][]string{\n        []string{"_", "_", "_"},\n        []string{"_", "_", "_"},\n        []string{"_", "_", "_"},\n    }\n\n    // The players take turns.\n    board[0][0] = "X"\n    board[2][2] = "O"\n    board[1][2] = "X"\n    board[1][0] = "O"\n    board[0][2] = "X"\n\n    for i := 0; i < len(board); i++ {\n        fmt.Printf("%s\\n", strings.Join(board[i], " "))\n    }\n}\n')),(0,l.kt)("h4",{id:"append-to-a-slice-appendsomeslice-0"},"append to a slice ",(0,l.kt)("inlineCode",{parentName:"h4"},"append(someSlice, 0)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the backing array of s is too small to fit all the given values a bigger array will be allocated. The returned slice will point to the newly allocated array.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"var s []int\ns = append(s, 0)            // append works on nil slices.\ns = append(s, 1)            // The slice grows as needed.\ns = append(s, 2, 3, 4)      // We can add more than one \n")),(0,l.kt)("h3",{id:"maps"},"Maps"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The zero value of a map is nil. A nil map has no keys, nor can keys be added.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m map[string]Vertex\nm = make(map[string]Vertex)\nm["Bell Labs"] = Vertex{\n    40.68433, -74.39967,\n}\nfmt.Println(m["Bell Labs"])\n\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"or as literal:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m = map[string]Vertex{\n    "Bell Labs": Vertex{\n        40.68433, -74.39967,\n    },\n    "Google": Vertex{\n        37.42202, -122.08408,\n    },\n}\nfmt.Println(m)\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Vertex struct {\n    Lat, Long float64\n}\nvar m = map[string]Vertex{\n    "Bell Labs": {40.68433, -74.39967},\n    "Google":    {37.42202, -122.08408},\n}\n\nfmt.Println(m)\n')),(0,l.kt)("h4",{id:"mutating-maps"},"mutating maps"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'    m := make(map[string]int)\n    m["Answer"] = 42                            // insert or update an element in map m\n    fmt.Println("The value:", m["Answer"])      // retrieve an element\n    delete(m, "Answer")                         // delete an element\n    fmt.Println("The value:", m["Answer"])      // -> The value: 0  <- !! notice the zero value here !! \n    answer, isPresent := m["Answer"]\n    fmt.Println(answer, isPresent)              // -> 0 false\n')),(0,l.kt)("h3",{id:"function-closures"},"Function closures"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For example, the adder function returns a closure. Each closure is bound to its own sum variable."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\nfunc main() {\n    pos, neg := adder(), adder()\n    for i := 0; i < 10; i++ {\n        fmt.Println(\n            pos(i),\n            neg(-2*i),\n        )\n    }\n}\n// -> 0 0\n// -> 1 -2\n// -> 3 -6\n// -> 6 -12\n// -> 10 -20\n// -> 15 -30\n// -> 21 -42\n// -> 28 -56\n// -> 36 -72\n// -> 45 -90\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"3-methods-and-interfaces"},"3. Methods and interfaces"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"has ",(0,l.kt)("strong",{parentName:"li"},"no")," classes")),(0,l.kt)("h3",{id:"define-methods-on-types"},"define methods on types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"You can only declare a method with a receiver whose type is ",(0,l.kt)("strong",{parentName:"li"},"defined in the same package")," as the method. You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as int).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type Coords struct{\n    x , y float64\n}\nfunc (c Coords) Absolute() float64{\n    return math.Sqrt(c.x*c.x + c.y*c.y)\n}\nvar ch = Coords{3,4}\nfmt.Println( ch.Absolute() )        // -> 5\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"even on non-struct types")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type MyFloat float64\n\nfunc (f MyFloat) Absolute() float64{\n    if f > 0 {\n        return float64(f)\n    }\n    return float64(-f)\n}\n")),(0,l.kt)("h3",{id:"pointer-receivers"},"Pointer receivers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Only")," Methods with pointer receivers can modify the value to which the receiver points.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\nver := Vertex{3,4}\nver.Scale(10)\nfmt.Println(ver)                    // {30. 40}\n// we could also pass in a pointer \np := &v\nfmt.Println( p.Scale(10) )          // {30, 40}\n\n// or the same function written with a pointer argument:\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\nve := Vertex{3,4}\nScaleFunc( &ve, 10 )                // notice how we need to pass in the pointer in this case\nScaleFunc( v, 5 )                   // WILL THROW AN ERROR\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"in gernal, all mehods on a given type should have either value or pointer receivers. But NOT a mixture of both!")),(0,l.kt)("h3",{id:"interfaces"},"Interfaces"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a type implements an interface implicit. Just by having the fitting method(s)."),(0,l.kt)("li",{parentName:"ul"},'could appear in any package without prearrangement (no a "implements" b keyword etc.)')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type ChessFigure interface{\n    Move() (int, int)\n}\n\ntype BlackPawn struct{\n    x, y int\n}\nfunc (v BlackPawn) Move() (int, int){\n    return v.x, (v.y -1)\n}\n\ntype WhitePawn  struct{\n    x, y int\n}\nfunc (v *WhitePawn) Move() (int, int) {\n    return v.x, (v.y + 1)\n}\n\nfunc main(){\n    var figure ChessFigure\n    pawn1 := WhitePawn{3,2}\n    figure = &pawn1                 // figure = pawn1 would throw and error : since only *WhitePawn implements the Move() method and WhitePawn does not.\n    fmt.Println(figure.Move())      // ->  3 3\n    pawn2 := BlackPawn{3,7}\n    figure = pawn2\n    fmt.Println(figure.Move())      // ->  3 6\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Element interface{\n    LogLength()\n}\nfunc describe(el Element){\n    fmt.Printf("value: %v , Type: %T \\n", el, el)\n}\n\ntype Word struct{\n    Str string\n}\nfunc (w *Word) LogLength(){\n    fmt.Println(len(w.Str))\n}\n\ntype Number int\nfunc (f Number) LogLength(){\n    fmt.Println( len(strconv.Itoa(int(f))) )\n}\n\nfunc main() {\n    var el Element\n    w := &Word{"Golang"}\n    el = w\n    el.LogLength()\n    describe(el)\n    n := Number(12345)\n    el = n\n    el.LogLength()\n    describe(el)\n}\n')),(0,l.kt)("h4",{id:"how-to-handle-nil---and-avoid-null-pointer-exceptions-in-go"},'how to handle nil - and avoid "null pointer" exceptions in go'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Element interface{\n    LogLength()\n}\nfunc describe(el Element){\n    fmt.Printf("value: %v , Type: %T \\n", el, el)\n}\n\ntype Word struct{\n    Str string\n}\nfunc (w *Word) LogLength(){\n    if w == nil{\n        fmt.Println("<nil>")\n        return\n    }\n    fmt.Println(len(w.Str))\n}\n\ntype Number int\nfunc (f Number) LogLength(){\n    fmt.Println( len(strconv.Itoa(int(f))) )\n}\n\nfunc main() {\n    var el Element\n    var w *Word\n    el = w\n    el.LogLength()\n    describe(el)\n    var n Number\n    el = n\n    el.LogLength()\n    describe(el)\n}\n// ->  <nil>\n// ->  value: <nil> , Type: *main.Word \n// ->  1\n// ->  value: 0 , Type: main.Number\n')),(0,l.kt)("h4",{id:"empty-interface"},"empty interface"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"empty interface: interface type that specifies zero methods- ",(0,l.kt)("inlineCode",{parentName:"li"},"interface{}")),(0,l.kt)("li",{parentName:"ul"},"accepts every type."),(0,l.kt)("li",{parentName:"ul"},"used by code that handles values of unknown type. Example ",(0,l.kt)("inlineCode",{parentName:"li"},"ftm.Print")," accepts any number of agruments of type ",(0,l.kt)("inlineCode",{parentName:"li"},"interface{}"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    var i interface{}\n    describe(i)         // -> (<nil>, <nil>)\n\n    i = 42\n    describe(i)         // -> (42, int)\n\n    i = "hello"\n    describe(i)         // -> (hello, string)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf("(%v, %T)\\n", i, i)\n}\n')),(0,l.kt)("h3",{id:"type-assertions"},"Type assertions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"t := i.(T)"),"  this tatement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"t, ok := i.(T)")," to test wheter an interface value holds a specific type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'var i interface{} = "hello"\n\ns := i.(string)\nfmt.Println(s)              // -> hello\n\ns, ok := i.(string)\nfmt.Println(s, ok)          // -> hello true\n\nf, ok := i.(float64)\nfmt.Println(f, ok)          // -> 0 false\n\n// f = i.(float64)          // panic: interface:conversion... error\n// fmt.Println(f)\n')),(0,l.kt)("h3",{id:"type-switches"},"Type switches"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"is a construct that allows several type assertions after another.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func testType(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Println("here v has type int: ", v)\n    case string:\n        fmt.Println("here v has type string: ", v)\n    default:\n        fmt.Printf("no match; here v is a type not int or string but a %T \\n", v)\n    }\n}\nfunc main(){\n    testType(21)\n    testType("golang")\n    testType(21.0)\n}\n')),(0,l.kt)("h3",{id:"stringers"},"Stringers"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type Stringer interface {\n    String() string\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"- packages like `fmt` look for this interface to print values. So we can make our Custom structs be printable by implementing this interface:\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type Person struct{\n    Name string\n    Age int\n    Height float64\n}\nfunc (p Person) String() string{\n    return fmt.Sprintf("%v,_%v_years_old,_height_%v", p.Name, p.Age, p.Height)\n}\nfunc main(){\n    a := Person{"Clark-Kent", 35, 1.85}\n    b := Person{"Peter-Parker", 25, 1.81}\n    fmt.Println(a, b)\n}\n// -> Clark-Kent,_35_years_old,_height_1.85 Peter-Parker,_25_years_old,_height_1.81\n')),(0,l.kt)("h4",{id:"example"},"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'type IPAddr [4]byte\n\n// TODO: Add a "String() string" method to IPAddr.\nfunc (ip IPAddr) String() string{\n    return fmt.Sprintf("%v.%v.%v.%v",ip[0], ip[1], ip[2], ip[3])\n}\n// :TODO\n\nfunc main() {\n    hosts := map[string]IPAddr{\n        "loopback":  {127, 0, 0, 1},\n        "googleDNS": {8, 8, 8, 8},\n    }\n    for name, ip := range hosts {\n        fmt.Printf("%v: %v\\n", name, ip)\n    }\n}\n\n// without the TODO: function\n// -> loopback: [127 0 0 1]\n// -> googleDNS: [8 8 8 8]\n\n// after implementing the TODO: function\n// -> loopback: 127.0.0.1\n// -> googleDNS: 8.8.8.8\n')),(0,l.kt)("h3",{id:"errors"},"Errors"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"go programs express error state with ",(0,l.kt)("inlineCode",{parentName:"li"},"error")," values similar to ",(0,l.kt)("inlineCode",{parentName:"li"},"fmt.Stringer"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type error interface {\n    Error() string\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"functions often return an ",(0,l.kt)("inlineCode",{parentName:"li"},"error")," value and calling code should handle errors by testing whether the error equals ",(0,l.kt)("inlineCode",{parentName:"li"},"nil"),":")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'i, err := strconv.Atoi("42")\nif err != nil {\n    fmt.Printf("couldn\'t convert number: %v\\n", err)\n    return\n}\nfmt.Println("Converted integer:", i)\n')),(0,l.kt)("h3",{id:"readers---data-sreams"},"Readers - Data Sreams"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the ",(0,l.kt)("inlineCode",{parentName:"li"},"io")," package specifies the ",(0,l.kt)("inlineCode",{parentName:"li"},"io.Reader")," interface, which represents the read end of a stream of data. Like files, network connections, audiostream...")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func (T) Read(b []byte) (n int, err error)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an ",(0,l.kt)("inlineCode",{parentName:"li"},"io.EOF")," error when the stream ends.")),(0,l.kt)("h4",{id:"the-following-example-creates-a-stringsreader-and-consumes-its-output-8-bytes-at-a-time"},"The following example creates a strings.Reader and consumes its output 8 bytes at a time:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "fmt"\n    "io"\n    "strings"\n)\n\nfunc main() {\n    r := strings.NewReader("Hello, Reader!")\n\n    b := make([]byte, 8)\n    for {\n        n, err := r.Read(b)\n        fmt.Printf("n = %v err = %v b = %v\\n", n, err, b)\n        fmt.Printf("b[:n] = %q\\n", b[:n])\n        if err == io.EOF {\n            break\n        }\n    }\n}\n// ->  n = 8 err = <nil> b = [72 101 108 108 111 44 32 82]\n// ->  b[:n] = "Hello, R"\n// ->  n = 6 err = <nil> b = [101 97 100 101 114 33 32 82]\n// ->  b[:n] = "eader!"\n// ->  n = 0 err = EOF b = [101 97 100 101 114 33 32 82]\n// ->  b[:n] = ""\n')),(0,l.kt)("h4",{id:"wrapping-a-reader-in-another-reader"},"Wrapping a reader in another reader"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"example in go/exercises")),(0,l.kt)("h3",{id:"images"},"Images"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://pkg.go.dev/image#Image"},"Package image")," defines the Image interface:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"package image\n\ntype Image interface {\n    ColorModel() color.Model\n    Bounds() Rectangle\n    At(x, y int) color.Color\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'\nimport (\n    "fmt"\n    "image"\n)\n\nfunc main() {\n    m := image.NewRGBA(image.Rect(0, 0, 100, 100))\n    fmt.Println(m.Bounds())\n    fmt.Println(m.At(0, 0).RGBA())\n}\n')),(0,l.kt)("h2",{id:"4-generics"},"4. Generics"),(0,l.kt)("h3",{id:"generic-functioins---unsing-type-parameters"},"Generic functioins - unsing Type parameters"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"functions that can work on multiple types. "),(0,l.kt)("li",{parentName:"ul"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'// returns the index of x in s, or -1 if not found.\nfunc FindIndex[T comparable](s []T, x T) int {\n    for i, v := range s {\n        // v and x are type T, which has the comparable\n        // constraint, so we can use == here.\n        if v == x {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc SumChars[T comparable] (s[]T, x T) int{\n    return 1\n}\n\nfunc main() {\n    // Index works on a slice of ints\n    si := []int{10, 20, 15, -10}\n    fmt.Println( FindIndex(si, 15) )                        // ->  2\n\n    // Index also works on a slice of strings\n    ss := []string{"hello", "cruel", "world"}\n    fmt.Println( FindIndex(ss, "hello") )                   // -> -1\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"comparable is a useful constraint that makes it possible to use the == and != operators on values of the type. In this example, we use it to compare a value to all slice elements until a match is found. This Index function works for any type that supports comparison.")),(0,l.kt)("h3",{id:"generic-types"},"Generic types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"useful for implementing generic data structures."),(0,l.kt)("li",{parentName:"ul"},"example below a linked-list, that holds values of any type")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"type List[T any] struct {\n    next *List[T]\n    val  T\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"example implementing a linked list structure")),(0,l.kt)("h3",{id:""}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "fmt"\n)\n\n// List represents a singly-linked list that holds values of any type.\ntype List[T any] struct {\n    value  T\n    next *List[T]\n}\n\n// returns length of the Linked-List\nfunc (l *List[T]) Len() int  {\n    count := 0\n    for el := l; el != nil; el = el.next {\n        count ++\n    }\n    return count\n}\n\n// insert element into linked list at pos with value\nfunc (l *List[T]) InsertAt(pos int, value T) *List[T] {\n    if l == nil || pos <= 0 {\n        return &List[T]{\n            value: value,\n            next:  l,\n        }\n    }\n    l.next = l.next.InsertAt(pos-1, value)\n    return l\n}\n\n// appends an element at the End of the Linked-List\nfunc (l *List[T]) Append(value T) *List[T] {\n    return l.InsertAt(l.Len(), value)\n}\n\n// String() to print the Linked-List\nfunc (l *List[T]) String() string {\n    if l == nil {\n        return "nil"\n    }\n    return fmt.Sprintf("%v->%v", l.value, l.next.String())\n}\n\nfunc main() {\n    var ll *List[string]\n    fmt.Println(ll)\n    ll = ll.Append("hello")\n    ll = ll.Append("something else")\n    fmt.Println(ll, "length:", ll.Len())\n\n}\n// ->  nil\n// ->  hello->something else->nil length: 2\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"adding to the above code we can fill our List with anything")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'\nfunc main() {\n    //...\n    var peopleList *List[Person]\n    peopleList = peopleList.Append(Person{"Adam", 22})\n    peopleList = peopleList.Append(Person{"Adam", 66})\n    peopleList = peopleList.Append(Person{"Adam", 44})\n    fmt.Println(peopleList)\n}\n\ntype Person struct{\n    Name string\n    Age int\n}\n\nfunc (p Person) String() string{\n    return fmt.Sprintf("%v_is_of_age:%v", p.Name, p.Age)\n}\n// -> Adam_is_of_age:22->Adam_is_of_age:66->Adam_is_of_age:44->nil\n')),(0,l.kt)("h2",{id:"5-concurrency"},"5. Concurrency"),(0,l.kt)("h3",{id:"goroutines"},"Goroutines"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a goroutine is a lightweight thread managed by the Go runtime. ",(0,l.kt)("inlineCode",{parentName:"li"},"go doStuff(a, b, c)")),(0,l.kt)("li",{parentName:"ul"},"the evaluation of doStuff() and a, b, c happens in the current goroutine. Execution of doStuff happens in the new goroutine."),(0,l.kt)("li",{parentName:"ul"},"Goroutines run in the same address space, so access to shared memory must be synchronized. The sync package provides useful primitives, although you won't need them much in Go as there are other primitives.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "fmt"\n    "time"\n)\n\nfunc say(s string) {\n    for i := 0; i < 3; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say("world")\n    say("hello")\n}\n')),(0,l.kt)("h3",{id:"channels"},"Channels"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Channels are typed pipes trough which you can send and receive values with the channel operator: ",(0,l.kt)("inlineCode",{parentName:"li"},"<-"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"ch := make(chan int)    // like maps and slices channels must be created before use\nch <- v                 // Send v to channel ch.\nv := <-ch               // Receive from ch, and assign value to v.\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The example below splits up building the sum of a slice in 2 goroutines:"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func sum(s []int, c chan int) {\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c // receive from c\n\n    fmt.Println(x, y, x+y)\n}\n")),(0,l.kt)("h4",{id:"buffered-channels"},"Buffered Channels"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ch := make(chan int, 100)")),(0,l.kt)("li",{parentName:"ul"},"Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.")),(0,l.kt)("h4",{id:"close-channels"},"Close Channels"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Only senders can close a channel to indicate that no more values will be sent."),(0,l.kt)("li",{parentName:"ul"},"Receivers can test wheter a channel has been closed by assigning a second parameter to the receive expression: ",(0,l.kt)("inlineCode",{parentName:"li"},"v, ok := range c")),(0,l.kt)("li",{parentName:"ul"},"Channels arent like files; you do not usually need to close them. Only if the the receiver must be told no more values are coming.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"func fibonacci(n int, c chan int) {\n    x, y := 0, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x+y\n    }\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n")),(0,l.kt)("h4",{id:"select"},"Select"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the ",(0,l.kt)("inlineCode",{parentName:"li"},"select")," statement lets a goroutine wait on multiple communication operations."),(0,l.kt)("li",{parentName:"ul"},"it blocks untill one of its cases can run. If multiple are ready then it chooses one ",(0,l.kt)("strong",{parentName:"li"},"random"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'func fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n            case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println("quit")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"we can use a default case to try a send or receive without blocking")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},"select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "fmt"\n    "time"\n)\n\nfunc main() {\n    tick := time.Tick(100 * time.Millisecond)\n    boom := time.After(500 * time.Millisecond)\n    for {\n        select {\n        case <-tick:\n            fmt.Println("tick.")\n        case <-boom:\n            fmt.Println("BOOM!")\n            return\n        default:\n            fmt.Println("    .")\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n')),(0,l.kt)("h3",{id:"syncmutex"},"sync.Mutex"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"if we want to make sure only one goroutine can access a variable at a time to avoid conflicts."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sync.Mutex")," and its two methods ",(0,l.kt)("inlineCode",{parentName:"li"},"Lock")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Unlock"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "fmt"\n    "sync"\n    "time"\n)\n\n// SafeCounter is safe to use concurrently.\ntype SafeCounter struct {\n    mu sync.Mutex\n    v  map[string]int\n}\n\n// Inc increments the counter for the given key.\nfunc (c *SafeCounter) Inc(key string) {\n    c.mu.Lock()\n    // Lock so only one goroutine at a time can access the map c.v.\n    c.v[key]++\n    c.mu.Unlock()\n}\n\n// Value returns the current value of the counter for the given key.\nfunc (c *SafeCounter) Value(key string) int {\n    c.mu.Lock()\n    // Lock so only one goroutine at a time can access the map c.v.\n    defer c.mu.Unlock()\n    return c.v[key]\n}\n\nfunc main() {\n    c := SafeCounter{v: make(map[string]int)}\n    for i := 0; i < 1000; i++ {\n        go c.Inc("somekey")\n    }\n\n    time.Sleep(time.Second)\n    fmt.Println(c.Value("somekey"))\n}\n')))}p.isMDXComponent=!0}}]);